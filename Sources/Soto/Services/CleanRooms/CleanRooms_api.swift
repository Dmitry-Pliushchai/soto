//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS CleanRooms service.
///
/// Welcome to the Clean Rooms API Reference. Clean Rooms is an Amazon Web Services service that helps multiple parties to join their data together in a secure collaboration workspace. In the collaboration, members who can query and receive results can get insights into the collective datasets without either party getting access to the other party's raw data. To learn more about Clean Rooms concepts, procedures, and best practices, see the Clean Rooms User Guide. To learn more about SQL commands, functions, and conditions supported in Clean Rooms, see the Clean Rooms SQL Reference.
public struct CleanRooms: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the CleanRooms client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "cleanrooms",
            serviceProtocol: .restjson,
            apiVersion: "2022-02-17",
            endpoint: endpoint,
            errorType: CleanRoomsErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Retrieves multiple analysis templates within a collaboration by their Amazon Resource Names (ARNs).
    public func batchGetCollaborationAnalysisTemplate(_ input: BatchGetCollaborationAnalysisTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BatchGetCollaborationAnalysisTemplateOutput> {
        return self.client.execute(operation: "BatchGetCollaborationAnalysisTemplate", path: "/collaborations/{collaborationIdentifier}/batch-analysistemplates", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves multiple schemas by their identifiers.
    public func batchGetSchema(_ input: BatchGetSchemaInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BatchGetSchemaOutput> {
        return self.client.execute(operation: "BatchGetSchema", path: "/collaborations/{collaborationIdentifier}/batch-schema", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new analysis template.
    public func createAnalysisTemplate(_ input: CreateAnalysisTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateAnalysisTemplateOutput> {
        return self.client.execute(operation: "CreateAnalysisTemplate", path: "/memberships/{membershipIdentifier}/analysistemplates", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new collaboration.
    public func createCollaboration(_ input: CreateCollaborationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCollaborationOutput> {
        return self.client.execute(operation: "CreateCollaboration", path: "/collaborations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Provides the details necessary to create a configured audience model association.
    public func createConfiguredAudienceModelAssociation(_ input: CreateConfiguredAudienceModelAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConfiguredAudienceModelAssociationOutput> {
        return self.client.execute(operation: "CreateConfiguredAudienceModelAssociation", path: "/memberships/{membershipIdentifier}/configuredaudiencemodelassociations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new configured table resource.
    public func createConfiguredTable(_ input: CreateConfiguredTableInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConfiguredTableOutput> {
        return self.client.execute(operation: "CreateConfiguredTable", path: "/configuredTables", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new analysis rule for a configured table. Currently, only one analysis rule can be created for a given configured table.
    public func createConfiguredTableAnalysisRule(_ input: CreateConfiguredTableAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConfiguredTableAnalysisRuleOutput> {
        return self.client.execute(operation: "CreateConfiguredTableAnalysisRule", path: "/configuredTables/{configuredTableIdentifier}/analysisRule", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a configured table association. A configured table association links a configured table with a collaboration.
    public func createConfiguredTableAssociation(_ input: CreateConfiguredTableAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConfiguredTableAssociationOutput> {
        return self.client.execute(operation: "CreateConfiguredTableAssociation", path: "/memberships/{membershipIdentifier}/configuredTableAssociations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a membership for a specific collaboration identifier and joins the collaboration.
    public func createMembership(_ input: CreateMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateMembershipOutput> {
        return self.client.execute(operation: "CreateMembership", path: "/memberships", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a privacy budget template for a specified membership. Each membership can have only one privacy budget template, but it can be deleted and recreated. If you need to change the privacy budget template for a membership, use the UpdatePrivacyBudgetTemplate operation.
    public func createPrivacyBudgetTemplate(_ input: CreatePrivacyBudgetTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreatePrivacyBudgetTemplateOutput> {
        return self.client.execute(operation: "CreatePrivacyBudgetTemplate", path: "/memberships/{membershipIdentifier}/privacybudgettemplates", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an analysis template.
    public func deleteAnalysisTemplate(_ input: DeleteAnalysisTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteAnalysisTemplateOutput> {
        return self.client.execute(operation: "DeleteAnalysisTemplate", path: "/memberships/{membershipIdentifier}/analysistemplates/{analysisTemplateIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a collaboration. It can only be called by the collaboration owner.
    public func deleteCollaboration(_ input: DeleteCollaborationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteCollaborationOutput> {
        return self.client.execute(operation: "DeleteCollaboration", path: "/collaborations/{collaborationIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Provides the information necessary to delete a configured audience model association.
    public func deleteConfiguredAudienceModelAssociation(_ input: DeleteConfiguredAudienceModelAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteConfiguredAudienceModelAssociationOutput> {
        return self.client.execute(operation: "DeleteConfiguredAudienceModelAssociation", path: "/memberships/{membershipIdentifier}/configuredaudiencemodelassociations/{configuredAudienceModelAssociationIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a configured table.
    public func deleteConfiguredTable(_ input: DeleteConfiguredTableInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteConfiguredTableOutput> {
        return self.client.execute(operation: "DeleteConfiguredTable", path: "/configuredTables/{configuredTableIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a configured table analysis rule.
    public func deleteConfiguredTableAnalysisRule(_ input: DeleteConfiguredTableAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteConfiguredTableAnalysisRuleOutput> {
        return self.client.execute(operation: "DeleteConfiguredTableAnalysisRule", path: "/configuredTables/{configuredTableIdentifier}/analysisRule/{analysisRuleType}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a configured table association.
    public func deleteConfiguredTableAssociation(_ input: DeleteConfiguredTableAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteConfiguredTableAssociationOutput> {
        return self.client.execute(operation: "DeleteConfiguredTableAssociation", path: "/memberships/{membershipIdentifier}/configuredTableAssociations/{configuredTableAssociationIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes the specified member from a collaboration. The removed member is placed in the Removed status and can't interact with the collaboration. The removed member's data is inaccessible to active members of the collaboration.
    public func deleteMember(_ input: DeleteMemberInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteMemberOutput> {
        return self.client.execute(operation: "DeleteMember", path: "/collaborations/{collaborationIdentifier}/member/{accountId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a specified membership. All resources under a membership must be deleted.
    public func deleteMembership(_ input: DeleteMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteMembershipOutput> {
        return self.client.execute(operation: "DeleteMembership", path: "/memberships/{membershipIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a privacy budget template for a specified membership.
    public func deletePrivacyBudgetTemplate(_ input: DeletePrivacyBudgetTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeletePrivacyBudgetTemplateOutput> {
        return self.client.execute(operation: "DeletePrivacyBudgetTemplate", path: "/memberships/{membershipIdentifier}/privacybudgettemplates/{privacyBudgetTemplateIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves an analysis template.
    public func getAnalysisTemplate(_ input: GetAnalysisTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetAnalysisTemplateOutput> {
        return self.client.execute(operation: "GetAnalysisTemplate", path: "/memberships/{membershipIdentifier}/analysistemplates/{analysisTemplateIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns metadata about a collaboration.
    public func getCollaboration(_ input: GetCollaborationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetCollaborationOutput> {
        return self.client.execute(operation: "GetCollaboration", path: "/collaborations/{collaborationIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves an analysis template within a collaboration.
    public func getCollaborationAnalysisTemplate(_ input: GetCollaborationAnalysisTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetCollaborationAnalysisTemplateOutput> {
        return self.client.execute(operation: "GetCollaborationAnalysisTemplate", path: "/collaborations/{collaborationIdentifier}/analysistemplates/{analysisTemplateArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a configured audience model association within a collaboration.
    public func getCollaborationConfiguredAudienceModelAssociation(_ input: GetCollaborationConfiguredAudienceModelAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetCollaborationConfiguredAudienceModelAssociationOutput> {
        return self.client.execute(operation: "GetCollaborationConfiguredAudienceModelAssociation", path: "/collaborations/{collaborationIdentifier}/configuredaudiencemodelassociations/{configuredAudienceModelAssociationIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns details about a specified privacy budget template.
    public func getCollaborationPrivacyBudgetTemplate(_ input: GetCollaborationPrivacyBudgetTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetCollaborationPrivacyBudgetTemplateOutput> {
        return self.client.execute(operation: "GetCollaborationPrivacyBudgetTemplate", path: "/collaborations/{collaborationIdentifier}/privacybudgettemplates/{privacyBudgetTemplateIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns information about a configured audience model association.
    public func getConfiguredAudienceModelAssociation(_ input: GetConfiguredAudienceModelAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConfiguredAudienceModelAssociationOutput> {
        return self.client.execute(operation: "GetConfiguredAudienceModelAssociation", path: "/memberships/{membershipIdentifier}/configuredaudiencemodelassociations/{configuredAudienceModelAssociationIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a configured table.
    public func getConfiguredTable(_ input: GetConfiguredTableInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConfiguredTableOutput> {
        return self.client.execute(operation: "GetConfiguredTable", path: "/configuredTables/{configuredTableIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a configured table analysis rule.
    public func getConfiguredTableAnalysisRule(_ input: GetConfiguredTableAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConfiguredTableAnalysisRuleOutput> {
        return self.client.execute(operation: "GetConfiguredTableAnalysisRule", path: "/configuredTables/{configuredTableIdentifier}/analysisRule/{analysisRuleType}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a configured table association.
    public func getConfiguredTableAssociation(_ input: GetConfiguredTableAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConfiguredTableAssociationOutput> {
        return self.client.execute(operation: "GetConfiguredTableAssociation", path: "/memberships/{membershipIdentifier}/configuredTableAssociations/{configuredTableAssociationIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a specified membership for an identifier.
    public func getMembership(_ input: GetMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetMembershipOutput> {
        return self.client.execute(operation: "GetMembership", path: "/memberships/{membershipIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns details for a specified privacy budget template.
    public func getPrivacyBudgetTemplate(_ input: GetPrivacyBudgetTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPrivacyBudgetTemplateOutput> {
        return self.client.execute(operation: "GetPrivacyBudgetTemplate", path: "/memberships/{membershipIdentifier}/privacybudgettemplates/{privacyBudgetTemplateIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns query processing metadata.
    public func getProtectedQuery(_ input: GetProtectedQueryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetProtectedQueryOutput> {
        return self.client.execute(operation: "GetProtectedQuery", path: "/memberships/{membershipIdentifier}/protectedQueries/{protectedQueryIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves the schema for a relation within a collaboration.
    public func getSchema(_ input: GetSchemaInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSchemaOutput> {
        return self.client.execute(operation: "GetSchema", path: "/collaborations/{collaborationIdentifier}/schemas/{name}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a schema analysis rule.
    public func getSchemaAnalysisRule(_ input: GetSchemaAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSchemaAnalysisRuleOutput> {
        return self.client.execute(operation: "GetSchemaAnalysisRule", path: "/collaborations/{collaborationIdentifier}/schemas/{name}/analysisRule/{type}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists analysis templates that the caller owns.
    public func listAnalysisTemplates(_ input: ListAnalysisTemplatesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAnalysisTemplatesOutput> {
        return self.client.execute(operation: "ListAnalysisTemplates", path: "/memberships/{membershipIdentifier}/analysistemplates", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists analysis templates within a collaboration.
    public func listCollaborationAnalysisTemplates(_ input: ListCollaborationAnalysisTemplatesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCollaborationAnalysisTemplatesOutput> {
        return self.client.execute(operation: "ListCollaborationAnalysisTemplates", path: "/collaborations/{collaborationIdentifier}/analysistemplates", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists configured audience model associations within a collaboration.
    public func listCollaborationConfiguredAudienceModelAssociations(_ input: ListCollaborationConfiguredAudienceModelAssociationsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCollaborationConfiguredAudienceModelAssociationsOutput> {
        return self.client.execute(operation: "ListCollaborationConfiguredAudienceModelAssociations", path: "/collaborations/{collaborationIdentifier}/configuredaudiencemodelassociations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns an array that summarizes each privacy budget template in a specified collaboration.
    public func listCollaborationPrivacyBudgetTemplates(_ input: ListCollaborationPrivacyBudgetTemplatesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCollaborationPrivacyBudgetTemplatesOutput> {
        return self.client.execute(operation: "ListCollaborationPrivacyBudgetTemplates", path: "/collaborations/{collaborationIdentifier}/privacybudgettemplates", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns an array that summarizes each privacy budget in a specified collaboration. The summary includes the collaboration ARN, creation time, creating account, and privacy budget details.
    public func listCollaborationPrivacyBudgets(_ input: ListCollaborationPrivacyBudgetsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCollaborationPrivacyBudgetsOutput> {
        return self.client.execute(operation: "ListCollaborationPrivacyBudgets", path: "/collaborations/{collaborationIdentifier}/privacybudgets", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists collaborations the caller owns, is active in, or has been invited to.
    public func listCollaborations(_ input: ListCollaborationsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCollaborationsOutput> {
        return self.client.execute(operation: "ListCollaborations", path: "/collaborations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists information about requested configured audience model associations.
    public func listConfiguredAudienceModelAssociations(_ input: ListConfiguredAudienceModelAssociationsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListConfiguredAudienceModelAssociationsOutput> {
        return self.client.execute(operation: "ListConfiguredAudienceModelAssociations", path: "/memberships/{membershipIdentifier}/configuredaudiencemodelassociations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists configured table associations for a membership.
    public func listConfiguredTableAssociations(_ input: ListConfiguredTableAssociationsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListConfiguredTableAssociationsOutput> {
        return self.client.execute(operation: "ListConfiguredTableAssociations", path: "/memberships/{membershipIdentifier}/configuredTableAssociations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists configured tables.
    public func listConfiguredTables(_ input: ListConfiguredTablesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListConfiguredTablesOutput> {
        return self.client.execute(operation: "ListConfiguredTables", path: "/configuredTables", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all members within a collaboration.
    public func listMembers(_ input: ListMembersInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListMembersOutput> {
        return self.client.execute(operation: "ListMembers", path: "/collaborations/{collaborationIdentifier}/members", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all memberships resources within the caller's account.
    public func listMemberships(_ input: ListMembershipsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListMembershipsOutput> {
        return self.client.execute(operation: "ListMemberships", path: "/memberships", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns detailed information about the privacy budget templates in a specified membership.
    public func listPrivacyBudgetTemplates(_ input: ListPrivacyBudgetTemplatesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListPrivacyBudgetTemplatesOutput> {
        return self.client.execute(operation: "ListPrivacyBudgetTemplates", path: "/memberships/{membershipIdentifier}/privacybudgettemplates", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns detailed information about the privacy budgets in a specified membership.
    public func listPrivacyBudgets(_ input: ListPrivacyBudgetsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListPrivacyBudgetsOutput> {
        return self.client.execute(operation: "ListPrivacyBudgets", path: "/memberships/{membershipIdentifier}/privacybudgets", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists protected queries, sorted by the most recent query.
    public func listProtectedQueries(_ input: ListProtectedQueriesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListProtectedQueriesOutput> {
        return self.client.execute(operation: "ListProtectedQueries", path: "/memberships/{membershipIdentifier}/protectedQueries", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the schemas for relations within a collaboration.
    public func listSchemas(_ input: ListSchemasInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSchemasOutput> {
        return self.client.execute(operation: "ListSchemas", path: "/collaborations/{collaborationIdentifier}/schemas", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all of the tags that have been added to a resource.
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceOutput> {
        return self.client.execute(operation: "ListTagsForResource", path: "/tags/{resourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// An estimate of the number of aggregation functions that the member who can query can run given epsilon and noise parameters.
    public func previewPrivacyImpact(_ input: PreviewPrivacyImpactInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PreviewPrivacyImpactOutput> {
        return self.client.execute(operation: "PreviewPrivacyImpact", path: "/memberships/{membershipIdentifier}/previewprivacyimpact", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a protected query that is started by Clean Rooms.
    public func startProtectedQuery(_ input: StartProtectedQueryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartProtectedQueryOutput> {
        return self.client.execute(operation: "StartProtectedQuery", path: "/memberships/{membershipIdentifier}/protectedQueries", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Tags a resource.
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceOutput> {
        return self.client.execute(operation: "TagResource", path: "/tags/{resourceArn}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes a tag or list of tags from a resource.
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceOutput> {
        return self.client.execute(operation: "UntagResource", path: "/tags/{resourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the analysis template metadata.
    public func updateAnalysisTemplate(_ input: UpdateAnalysisTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateAnalysisTemplateOutput> {
        return self.client.execute(operation: "UpdateAnalysisTemplate", path: "/memberships/{membershipIdentifier}/analysistemplates/{analysisTemplateIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates collaboration metadata and can only be called by the collaboration owner.
    public func updateCollaboration(_ input: UpdateCollaborationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateCollaborationOutput> {
        return self.client.execute(operation: "UpdateCollaboration", path: "/collaborations/{collaborationIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Provides the details necessary to update a configured audience model association.
    public func updateConfiguredAudienceModelAssociation(_ input: UpdateConfiguredAudienceModelAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConfiguredAudienceModelAssociationOutput> {
        return self.client.execute(operation: "UpdateConfiguredAudienceModelAssociation", path: "/memberships/{membershipIdentifier}/configuredaudiencemodelassociations/{configuredAudienceModelAssociationIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a configured table.
    public func updateConfiguredTable(_ input: UpdateConfiguredTableInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConfiguredTableOutput> {
        return self.client.execute(operation: "UpdateConfiguredTable", path: "/configuredTables/{configuredTableIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a configured table analysis rule.
    public func updateConfiguredTableAnalysisRule(_ input: UpdateConfiguredTableAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConfiguredTableAnalysisRuleOutput> {
        return self.client.execute(operation: "UpdateConfiguredTableAnalysisRule", path: "/configuredTables/{configuredTableIdentifier}/analysisRule/{analysisRuleType}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a configured table association.
    public func updateConfiguredTableAssociation(_ input: UpdateConfiguredTableAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConfiguredTableAssociationOutput> {
        return self.client.execute(operation: "UpdateConfiguredTableAssociation", path: "/memberships/{membershipIdentifier}/configuredTableAssociations/{configuredTableAssociationIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a membership.
    public func updateMembership(_ input: UpdateMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateMembershipOutput> {
        return self.client.execute(operation: "UpdateMembership", path: "/memberships/{membershipIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the privacy budget template for the specified membership.
    public func updatePrivacyBudgetTemplate(_ input: UpdatePrivacyBudgetTemplateInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdatePrivacyBudgetTemplateOutput> {
        return self.client.execute(operation: "UpdatePrivacyBudgetTemplate", path: "/memberships/{membershipIdentifier}/privacybudgettemplates/{privacyBudgetTemplateIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the processing of a currently running query.
    public func updateProtectedQuery(_ input: UpdateProtectedQueryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateProtectedQueryOutput> {
        return self.client.execute(operation: "UpdateProtectedQuery", path: "/memberships/{membershipIdentifier}/protectedQueries/{protectedQueryIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension CleanRooms {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: CleanRooms, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension CleanRooms {
    /// Lists configured audience model associations within a collaboration.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listCollaborationConfiguredAudienceModelAssociationsPaginator<Result>(
        _ input: ListCollaborationConfiguredAudienceModelAssociationsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListCollaborationConfiguredAudienceModelAssociationsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listCollaborationConfiguredAudienceModelAssociations,
            inputKey: \ListCollaborationConfiguredAudienceModelAssociationsInput.nextToken,
            outputKey: \ListCollaborationConfiguredAudienceModelAssociationsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listCollaborationConfiguredAudienceModelAssociationsPaginator(
        _ input: ListCollaborationConfiguredAudienceModelAssociationsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListCollaborationConfiguredAudienceModelAssociationsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listCollaborationConfiguredAudienceModelAssociations,
            inputKey: \ListCollaborationConfiguredAudienceModelAssociationsInput.nextToken,
            outputKey: \ListCollaborationConfiguredAudienceModelAssociationsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Returns an array that summarizes each privacy budget template in a specified collaboration.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listCollaborationPrivacyBudgetTemplatesPaginator<Result>(
        _ input: ListCollaborationPrivacyBudgetTemplatesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListCollaborationPrivacyBudgetTemplatesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listCollaborationPrivacyBudgetTemplates,
            inputKey: \ListCollaborationPrivacyBudgetTemplatesInput.nextToken,
            outputKey: \ListCollaborationPrivacyBudgetTemplatesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listCollaborationPrivacyBudgetTemplatesPaginator(
        _ input: ListCollaborationPrivacyBudgetTemplatesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListCollaborationPrivacyBudgetTemplatesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listCollaborationPrivacyBudgetTemplates,
            inputKey: \ListCollaborationPrivacyBudgetTemplatesInput.nextToken,
            outputKey: \ListCollaborationPrivacyBudgetTemplatesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Returns an array that summarizes each privacy budget in a specified collaboration. The summary includes the collaboration ARN, creation time, creating account, and privacy budget details.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listCollaborationPrivacyBudgetsPaginator<Result>(
        _ input: ListCollaborationPrivacyBudgetsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListCollaborationPrivacyBudgetsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listCollaborationPrivacyBudgets,
            inputKey: \ListCollaborationPrivacyBudgetsInput.nextToken,
            outputKey: \ListCollaborationPrivacyBudgetsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listCollaborationPrivacyBudgetsPaginator(
        _ input: ListCollaborationPrivacyBudgetsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListCollaborationPrivacyBudgetsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listCollaborationPrivacyBudgets,
            inputKey: \ListCollaborationPrivacyBudgetsInput.nextToken,
            outputKey: \ListCollaborationPrivacyBudgetsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists information about requested configured audience model associations.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listConfiguredAudienceModelAssociationsPaginator<Result>(
        _ input: ListConfiguredAudienceModelAssociationsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListConfiguredAudienceModelAssociationsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listConfiguredAudienceModelAssociations,
            inputKey: \ListConfiguredAudienceModelAssociationsInput.nextToken,
            outputKey: \ListConfiguredAudienceModelAssociationsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listConfiguredAudienceModelAssociationsPaginator(
        _ input: ListConfiguredAudienceModelAssociationsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListConfiguredAudienceModelAssociationsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listConfiguredAudienceModelAssociations,
            inputKey: \ListConfiguredAudienceModelAssociationsInput.nextToken,
            outputKey: \ListConfiguredAudienceModelAssociationsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Returns detailed information about the privacy budget templates in a specified membership.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPrivacyBudgetTemplatesPaginator<Result>(
        _ input: ListPrivacyBudgetTemplatesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPrivacyBudgetTemplatesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listPrivacyBudgetTemplates,
            inputKey: \ListPrivacyBudgetTemplatesInput.nextToken,
            outputKey: \ListPrivacyBudgetTemplatesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPrivacyBudgetTemplatesPaginator(
        _ input: ListPrivacyBudgetTemplatesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPrivacyBudgetTemplatesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listPrivacyBudgetTemplates,
            inputKey: \ListPrivacyBudgetTemplatesInput.nextToken,
            outputKey: \ListPrivacyBudgetTemplatesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Returns detailed information about the privacy budgets in a specified membership.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPrivacyBudgetsPaginator<Result>(
        _ input: ListPrivacyBudgetsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPrivacyBudgetsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listPrivacyBudgets,
            inputKey: \ListPrivacyBudgetsInput.nextToken,
            outputKey: \ListPrivacyBudgetsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPrivacyBudgetsPaginator(
        _ input: ListPrivacyBudgetsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPrivacyBudgetsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listPrivacyBudgets,
            inputKey: \ListPrivacyBudgetsInput.nextToken,
            outputKey: \ListPrivacyBudgetsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists protected queries, sorted by the most recent query.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listProtectedQueriesPaginator<Result>(
        _ input: ListProtectedQueriesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListProtectedQueriesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listProtectedQueries,
            inputKey: \ListProtectedQueriesInput.nextToken,
            outputKey: \ListProtectedQueriesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listProtectedQueriesPaginator(
        _ input: ListProtectedQueriesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListProtectedQueriesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listProtectedQueries,
            inputKey: \ListProtectedQueriesInput.nextToken,
            outputKey: \ListProtectedQueriesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension CleanRooms.ListCollaborationConfiguredAudienceModelAssociationsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRooms.ListCollaborationConfiguredAudienceModelAssociationsInput {
        return .init(
            collaborationIdentifier: self.collaborationIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension CleanRooms.ListCollaborationPrivacyBudgetTemplatesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRooms.ListCollaborationPrivacyBudgetTemplatesInput {
        return .init(
            collaborationIdentifier: self.collaborationIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension CleanRooms.ListCollaborationPrivacyBudgetsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRooms.ListCollaborationPrivacyBudgetsInput {
        return .init(
            collaborationIdentifier: self.collaborationIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            privacyBudgetType: self.privacyBudgetType
        )
    }
}

extension CleanRooms.ListConfiguredAudienceModelAssociationsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRooms.ListConfiguredAudienceModelAssociationsInput {
        return .init(
            maxResults: self.maxResults,
            membershipIdentifier: self.membershipIdentifier,
            nextToken: token
        )
    }
}

extension CleanRooms.ListPrivacyBudgetTemplatesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRooms.ListPrivacyBudgetTemplatesInput {
        return .init(
            maxResults: self.maxResults,
            membershipIdentifier: self.membershipIdentifier,
            nextToken: token
        )
    }
}

extension CleanRooms.ListPrivacyBudgetsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRooms.ListPrivacyBudgetsInput {
        return .init(
            maxResults: self.maxResults,
            membershipIdentifier: self.membershipIdentifier,
            nextToken: token,
            privacyBudgetType: self.privacyBudgetType
        )
    }
}

extension CleanRooms.ListProtectedQueriesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRooms.ListProtectedQueriesInput {
        return .init(
            maxResults: self.maxResults,
            membershipIdentifier: self.membershipIdentifier,
            nextToken: token,
            status: self.status
        )
    }
}
