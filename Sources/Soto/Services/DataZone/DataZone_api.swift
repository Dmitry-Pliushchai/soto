//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS DataZone service.
///
/// Amazon DataZone is a data management service that enables you to catalog, discover, govern, share, and analyze your data. With Amazon DataZone, you can share and access your data across accounts and supported regions. Amazon DataZone simplifies your experience across Amazon Web Services services, including, but not limited to, Amazon Redshift, Amazon Athena, Amazon Web Services Glue, and Amazon Web Services Lake Formation.
public struct DataZone: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the DataZone client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "datazone",
            serviceProtocol: .restjson,
            apiVersion: "2018-05-10",
            endpoint: endpoint,
            serviceEndpoints: [
                "af-south-1": "datazone.af-south-1.api.aws",
                "ap-east-1": "datazone.ap-east-1.api.aws",
                "ap-northeast-1": "datazone.ap-northeast-1.api.aws",
                "ap-northeast-2": "datazone.ap-northeast-2.api.aws",
                "ap-northeast-3": "datazone.ap-northeast-3.api.aws",
                "ap-south-1": "datazone.ap-south-1.api.aws",
                "ap-south-2": "datazone.ap-south-2.api.aws",
                "ap-southeast-1": "datazone.ap-southeast-1.api.aws",
                "ap-southeast-2": "datazone.ap-southeast-2.api.aws",
                "ap-southeast-3": "datazone.ap-southeast-3.api.aws",
                "ap-southeast-4": "datazone.ap-southeast-4.api.aws",
                "ca-central-1": "datazone.ca-central-1.api.aws",
                "cn-north-1": "datazone.cn-north-1.api.amazonwebservices.com.cn",
                "cn-northwest-1": "datazone.cn-northwest-1.api.amazonwebservices.com.cn",
                "eu-central-1": "datazone.eu-central-1.api.aws",
                "eu-central-2": "datazone.eu-central-2.api.aws",
                "eu-north-1": "datazone.eu-north-1.api.aws",
                "eu-south-1": "datazone.eu-south-1.api.aws",
                "eu-south-2": "datazone.eu-south-2.api.aws",
                "eu-west-1": "datazone.eu-west-1.api.aws",
                "eu-west-2": "datazone.eu-west-2.api.aws",
                "eu-west-3": "datazone.eu-west-3.api.aws",
                "il-central-1": "datazone.il-central-1.api.aws",
                "me-central-1": "datazone.me-central-1.api.aws",
                "me-south-1": "datazone.me-south-1.api.aws",
                "sa-east-1": "datazone.sa-east-1.api.aws",
                "us-east-1": "datazone.us-east-1.api.aws",
                "us-east-2": "datazone.us-east-2.api.aws",
                "us-gov-east-1": "datazone.us-gov-east-1.api.aws",
                "us-gov-west-1": "datazone.us-gov-west-1.api.aws",
                "us-west-1": "datazone.us-west-1.api.aws",
                "us-west-2": "datazone.us-west-2.api.aws"
            ],
            variantEndpoints: [
                [.fips]: .init(endpoints: [
                    "af-south-1": "datazone-fips.af-south-1.api.aws",
                    "ap-east-1": "datazone-fips.ap-east-1.api.aws",
                    "ap-northeast-1": "datazone-fips.ap-northeast-1.api.aws",
                    "ap-northeast-2": "datazone-fips.ap-northeast-2.api.aws",
                    "ap-northeast-3": "datazone-fips.ap-northeast-3.api.aws",
                    "ap-south-1": "datazone-fips.ap-south-1.api.aws",
                    "ap-south-2": "datazone-fips.ap-south-2.api.aws",
                    "ap-southeast-1": "datazone-fips.ap-southeast-1.api.aws",
                    "ap-southeast-2": "datazone-fips.ap-southeast-2.api.aws",
                    "ap-southeast-3": "datazone-fips.ap-southeast-3.api.aws",
                    "ap-southeast-4": "datazone-fips.ap-southeast-4.api.aws",
                    "ca-central-1": "datazone-fips.ca-central-1.amazonaws.com",
                    "cn-north-1": "datazone-fips.cn-north-1.api.amazonwebservices.com.cn",
                    "cn-northwest-1": "datazone-fips.cn-northwest-1.api.amazonwebservices.com.cn",
                    "eu-central-1": "datazone-fips.eu-central-1.api.aws",
                    "eu-central-2": "datazone-fips.eu-central-2.api.aws",
                    "eu-north-1": "datazone-fips.eu-north-1.api.aws",
                    "eu-south-1": "datazone-fips.eu-south-1.api.aws",
                    "eu-south-2": "datazone-fips.eu-south-2.api.aws",
                    "eu-west-1": "datazone-fips.eu-west-1.api.aws",
                    "eu-west-2": "datazone-fips.eu-west-2.api.aws",
                    "eu-west-3": "datazone-fips.eu-west-3.api.aws",
                    "il-central-1": "datazone-fips.il-central-1.api.aws",
                    "me-central-1": "datazone-fips.me-central-1.api.aws",
                    "me-south-1": "datazone-fips.me-south-1.api.aws",
                    "sa-east-1": "datazone-fips.sa-east-1.api.aws",
                    "us-east-1": "datazone-fips.us-east-1.amazonaws.com",
                    "us-east-2": "datazone-fips.us-east-2.amazonaws.com",
                    "us-gov-east-1": "datazone-fips.us-gov-east-1.api.aws",
                    "us-gov-west-1": "datazone-fips.us-gov-west-1.api.aws",
                    "us-west-1": "datazone-fips.us-west-1.api.aws",
                    "us-west-2": "datazone-fips.us-west-2.amazonaws.com"
                ])
            ],
            errorType: DataZoneErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Accepts automatically generated business-friendly metadata for your Amazon DataZone assets.
    public func acceptPredictions(_ input: AcceptPredictionsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AcceptPredictionsOutput> {
        return self.client.execute(operation: "AcceptPredictions", path: "/v2/domains/{domainIdentifier}/assets/{identifier}/accept-predictions", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Accepts a subscription request to a specific asset.
    public func acceptSubscriptionRequest(_ input: AcceptSubscriptionRequestInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AcceptSubscriptionRequestOutput> {
        return self.client.execute(operation: "AcceptSubscriptionRequest", path: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}/accept", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Cancels the subscription to the specified asset.
    public func cancelSubscription(_ input: CancelSubscriptionInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CancelSubscriptionOutput> {
        return self.client.execute(operation: "CancelSubscription", path: "/v2/domains/{domainIdentifier}/subscriptions/{identifier}/cancel", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an asset in Amazon DataZone catalog.
    public func createAsset(_ input: CreateAssetInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateAssetOutput> {
        return self.client.execute(operation: "CreateAsset", path: "/v2/domains/{domainIdentifier}/assets", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a revision of the asset.
    public func createAssetRevision(_ input: CreateAssetRevisionInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateAssetRevisionOutput> {
        return self.client.execute(operation: "CreateAssetRevision", path: "/v2/domains/{domainIdentifier}/assets/{identifier}/revisions", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a custom asset type.
    public func createAssetType(_ input: CreateAssetTypeInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateAssetTypeOutput> {
        return self.client.execute(operation: "CreateAssetType", path: "/v2/domains/{domainIdentifier}/asset-types", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an Amazon DataZone data source.
    public func createDataSource(_ input: CreateDataSourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDataSourceOutput> {
        return self.client.execute(operation: "CreateDataSource", path: "/v2/domains/{domainIdentifier}/data-sources", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an Amazon DataZone domain.
    public func createDomain(_ input: CreateDomainInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDomainOutput> {
        return self.client.execute(operation: "CreateDomain", path: "/v2/domains", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Create an Amazon DataZone environment.
    public func createEnvironment(_ input: CreateEnvironmentInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateEnvironmentOutput> {
        return self.client.execute(operation: "CreateEnvironment", path: "/v2/domains/{domainIdentifier}/environments", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an Amazon DataZone environment profile.
    public func createEnvironmentProfile(_ input: CreateEnvironmentProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateEnvironmentProfileOutput> {
        return self.client.execute(operation: "CreateEnvironmentProfile", path: "/v2/domains/{domainIdentifier}/environment-profiles", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a metadata form type.
    public func createFormType(_ input: CreateFormTypeInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateFormTypeOutput> {
        return self.client.execute(operation: "CreateFormType", path: "/v2/domains/{domainIdentifier}/form-types", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an Amazon DataZone business glossary.
    public func createGlossary(_ input: CreateGlossaryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateGlossaryOutput> {
        return self.client.execute(operation: "CreateGlossary", path: "/v2/domains/{domainIdentifier}/glossaries", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a business glossary term.
    public func createGlossaryTerm(_ input: CreateGlossaryTermInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateGlossaryTermOutput> {
        return self.client.execute(operation: "CreateGlossaryTerm", path: "/v2/domains/{domainIdentifier}/glossary-terms", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a group profile in Amazon DataZone.
    public func createGroupProfile(_ input: CreateGroupProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateGroupProfileOutput> {
        return self.client.execute(operation: "CreateGroupProfile", path: "/v2/domains/{domainIdentifier}/group-profiles", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func createListingChangeSet(_ input: CreateListingChangeSetInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateListingChangeSetOutput> {
        return self.client.execute(operation: "CreateListingChangeSet", path: "/v2/domains/{domainIdentifier}/listings/change-set", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an Amazon DataZone project.
    public func createProject(_ input: CreateProjectInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateProjectOutput> {
        return self.client.execute(operation: "CreateProject", path: "/v2/domains/{domainIdentifier}/projects", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a project membership in Amazon DataZone.
    public func createProjectMembership(_ input: CreateProjectMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateProjectMembershipOutput> {
        return self.client.execute(operation: "CreateProjectMembership", path: "/v2/domains/{domainIdentifier}/projects/{projectIdentifier}/createMembership", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a subsscription grant in Amazon DataZone.
    public func createSubscriptionGrant(_ input: CreateSubscriptionGrantInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateSubscriptionGrantOutput> {
        return self.client.execute(operation: "CreateSubscriptionGrant", path: "/v2/domains/{domainIdentifier}/subscription-grants", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a subscription request in Amazon DataZone.
    public func createSubscriptionRequest(_ input: CreateSubscriptionRequestInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateSubscriptionRequestOutput> {
        return self.client.execute(operation: "CreateSubscriptionRequest", path: "/v2/domains/{domainIdentifier}/subscription-requests", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a subscription target in Amazon DataZone.
    public func createSubscriptionTarget(_ input: CreateSubscriptionTargetInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateSubscriptionTargetOutput> {
        return self.client.execute(operation: "CreateSubscriptionTarget", path: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a user profile in Amazon DataZone.
    public func createUserProfile(_ input: CreateUserProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateUserProfileOutput> {
        return self.client.execute(operation: "CreateUserProfile", path: "/v2/domains/{domainIdentifier}/user-profiles", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delets an asset in Amazon DataZone.
    public func deleteAsset(_ input: DeleteAssetInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteAssetOutput> {
        return self.client.execute(operation: "DeleteAsset", path: "/v2/domains/{domainIdentifier}/assets/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an asset type in Amazon DataZone.
    public func deleteAssetType(_ input: DeleteAssetTypeInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteAssetTypeOutput> {
        return self.client.execute(operation: "DeleteAssetType", path: "/v2/domains/{domainIdentifier}/asset-types/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a data source in Amazon DataZone.
    public func deleteDataSource(_ input: DeleteDataSourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteDataSourceOutput> {
        return self.client.execute(operation: "DeleteDataSource", path: "/v2/domains/{domainIdentifier}/data-sources/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a Amazon DataZone domain.
    public func deleteDomain(_ input: DeleteDomainInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteDomainOutput> {
        return self.client.execute(operation: "DeleteDomain", path: "/v2/domains/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an environment in Amazon DataZone.
    @discardableResult public func deleteEnvironment(_ input: DeleteEnvironmentInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteEnvironment", path: "/v2/domains/{domainIdentifier}/environments/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the blueprint configuration in Amazon DataZone.
    public func deleteEnvironmentBlueprintConfiguration(_ input: DeleteEnvironmentBlueprintConfigurationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteEnvironmentBlueprintConfigurationOutput> {
        return self.client.execute(operation: "DeleteEnvironmentBlueprintConfiguration", path: "/v2/domains/{domainIdentifier}/environment-blueprint-configurations/{environmentBlueprintIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an environment profile in Amazon DataZone.
    @discardableResult public func deleteEnvironmentProfile(_ input: DeleteEnvironmentProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteEnvironmentProfile", path: "/v2/domains/{domainIdentifier}/environment-profiles/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delets and metadata form type in Amazon DataZone.
    public func deleteFormType(_ input: DeleteFormTypeInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteFormTypeOutput> {
        return self.client.execute(operation: "DeleteFormType", path: "/v2/domains/{domainIdentifier}/form-types/{formTypeIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a business glossary in Amazon DataZone.
    public func deleteGlossary(_ input: DeleteGlossaryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteGlossaryOutput> {
        return self.client.execute(operation: "DeleteGlossary", path: "/v2/domains/{domainIdentifier}/glossaries/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a business glossary term in Amazon DataZone.
    public func deleteGlossaryTerm(_ input: DeleteGlossaryTermInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteGlossaryTermOutput> {
        return self.client.execute(operation: "DeleteGlossaryTerm", path: "/v2/domains/{domainIdentifier}/glossary-terms/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func deleteListing(_ input: DeleteListingInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteListingOutput> {
        return self.client.execute(operation: "DeleteListing", path: "/v2/domains/{domainIdentifier}/listings/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a project in Amazon DataZone.
    public func deleteProject(_ input: DeleteProjectInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteProjectOutput> {
        return self.client.execute(operation: "DeleteProject", path: "/v2/domains/{domainIdentifier}/projects/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes project membership in Amazon DataZone.
    public func deleteProjectMembership(_ input: DeleteProjectMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteProjectMembershipOutput> {
        return self.client.execute(operation: "DeleteProjectMembership", path: "/v2/domains/{domainIdentifier}/projects/{projectIdentifier}/deleteMembership", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes and subscription grant in Amazon DataZone.
    public func deleteSubscriptionGrant(_ input: DeleteSubscriptionGrantInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteSubscriptionGrantOutput> {
        return self.client.execute(operation: "DeleteSubscriptionGrant", path: "/v2/domains/{domainIdentifier}/subscription-grants/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a subscription request in Amazon DataZone.
    @discardableResult public func deleteSubscriptionRequest(_ input: DeleteSubscriptionRequestInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteSubscriptionRequest", path: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a subscription target in Amazon DataZone.
    @discardableResult public func deleteSubscriptionTarget(_ input: DeleteSubscriptionTargetInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteSubscriptionTarget", path: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets/{identifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an Amazon DataZone asset.
    public func getAsset(_ input: GetAssetInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetAssetOutput> {
        return self.client.execute(operation: "GetAsset", path: "/v2/domains/{domainIdentifier}/assets/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an Amazon DataZone asset type.
    public func getAssetType(_ input: GetAssetTypeInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetAssetTypeOutput> {
        return self.client.execute(operation: "GetAssetType", path: "/v2/domains/{domainIdentifier}/asset-types/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an Amazon DataZone data source.
    public func getDataSource(_ input: GetDataSourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDataSourceOutput> {
        return self.client.execute(operation: "GetDataSource", path: "/v2/domains/{domainIdentifier}/data-sources/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an Amazon DataZone data source run.
    public func getDataSourceRun(_ input: GetDataSourceRunInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDataSourceRunOutput> {
        return self.client.execute(operation: "GetDataSourceRun", path: "/v2/domains/{domainIdentifier}/data-source-runs/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an Amazon DataZone domain.
    public func getDomain(_ input: GetDomainInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDomainOutput> {
        return self.client.execute(operation: "GetDomain", path: "/v2/domains/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an Amazon DataZone environment.
    public func getEnvironment(_ input: GetEnvironmentInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetEnvironmentOutput> {
        return self.client.execute(operation: "GetEnvironment", path: "/v2/domains/{domainIdentifier}/environments/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an Amazon DataZone blueprint.
    public func getEnvironmentBlueprint(_ input: GetEnvironmentBlueprintInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetEnvironmentBlueprintOutput> {
        return self.client.execute(operation: "GetEnvironmentBlueprint", path: "/v2/domains/{domainIdentifier}/environment-blueprints/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the blueprint configuration in Amazon DataZone.
    public func getEnvironmentBlueprintConfiguration(_ input: GetEnvironmentBlueprintConfigurationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetEnvironmentBlueprintConfigurationOutput> {
        return self.client.execute(operation: "GetEnvironmentBlueprintConfiguration", path: "/v2/domains/{domainIdentifier}/environment-blueprint-configurations/{environmentBlueprintIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an evinronment profile in Amazon DataZone.
    public func getEnvironmentProfile(_ input: GetEnvironmentProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetEnvironmentProfileOutput> {
        return self.client.execute(operation: "GetEnvironmentProfile", path: "/v2/domains/{domainIdentifier}/environment-profiles/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a metadata form type in Amazon DataZone.
    public func getFormType(_ input: GetFormTypeInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetFormTypeOutput> {
        return self.client.execute(operation: "GetFormType", path: "/v2/domains/{domainIdentifier}/form-types/{formTypeIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a business glossary in Amazon DataZone.
    public func getGlossary(_ input: GetGlossaryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGlossaryOutput> {
        return self.client.execute(operation: "GetGlossary", path: "/v2/domains/{domainIdentifier}/glossaries/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a business glossary term in Amazon DataZone.
    public func getGlossaryTerm(_ input: GetGlossaryTermInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGlossaryTermOutput> {
        return self.client.execute(operation: "GetGlossaryTerm", path: "/v2/domains/{domainIdentifier}/glossary-terms/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a group profile in Amazon DataZone.
    public func getGroupProfile(_ input: GetGroupProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGroupProfileOutput> {
        return self.client.execute(operation: "GetGroupProfile", path: "/v2/domains/{domainIdentifier}/group-profiles/{groupIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the data portal URL for the specified Amazon DataZone domain.
    public func getIamPortalLoginUrl(_ input: GetIamPortalLoginUrlInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetIamPortalLoginUrlOutput> {
        return self.client.execute(operation: "GetIamPortalLoginUrl", path: "/v2/domains/{domainIdentifier}/get-portal-login-url", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getListing(_ input: GetListingInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetListingOutput> {
        return self.client.execute(operation: "GetListing", path: "/v2/domains/{domainIdentifier}/listings/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a project in Amazon DataZone.
    public func getProject(_ input: GetProjectInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetProjectOutput> {
        return self.client.execute(operation: "GetProject", path: "/v2/domains/{domainIdentifier}/projects/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a subscription in Amazon DataZone.
    public func getSubscription(_ input: GetSubscriptionInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSubscriptionOutput> {
        return self.client.execute(operation: "GetSubscription", path: "/v2/domains/{domainIdentifier}/subscriptions/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the subscription grant in Amazon DataZone.
    public func getSubscriptionGrant(_ input: GetSubscriptionGrantInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSubscriptionGrantOutput> {
        return self.client.execute(operation: "GetSubscriptionGrant", path: "/v2/domains/{domainIdentifier}/subscription-grants/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the details of the specified subscription request.
    public func getSubscriptionRequestDetails(_ input: GetSubscriptionRequestDetailsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSubscriptionRequestDetailsOutput> {
        return self.client.execute(operation: "GetSubscriptionRequestDetails", path: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the subscription target in Amazon DataZone.
    public func getSubscriptionTarget(_ input: GetSubscriptionTargetInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSubscriptionTargetOutput> {
        return self.client.execute(operation: "GetSubscriptionTarget", path: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets/{identifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a user profile in Amazon DataZone.
    public func getUserProfile(_ input: GetUserProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetUserProfileOutput> {
        return self.client.execute(operation: "GetUserProfile", path: "/v2/domains/{domainIdentifier}/user-profiles/{userIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the revisions for the asset.
    public func listAssetRevisions(_ input: ListAssetRevisionsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAssetRevisionsOutput> {
        return self.client.execute(operation: "ListAssetRevisions", path: "/v2/domains/{domainIdentifier}/assets/{identifier}/revisions", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists data source run activities.
    public func listDataSourceRunActivities(_ input: ListDataSourceRunActivitiesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDataSourceRunActivitiesOutput> {
        return self.client.execute(operation: "ListDataSourceRunActivities", path: "/v2/domains/{domainIdentifier}/data-source-runs/{identifier}/activities", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists data source runs in Amazon DataZone.
    public func listDataSourceRuns(_ input: ListDataSourceRunsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDataSourceRunsOutput> {
        return self.client.execute(operation: "ListDataSourceRuns", path: "/v2/domains/{domainIdentifier}/data-sources/{dataSourceIdentifier}/runs", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists data sources in Amazon DataZone.
    public func listDataSources(_ input: ListDataSourcesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDataSourcesOutput> {
        return self.client.execute(operation: "ListDataSources", path: "/v2/domains/{domainIdentifier}/data-sources", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists Amazon DataZone domains.
    public func listDomains(_ input: ListDomainsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDomainsOutput> {
        return self.client.execute(operation: "ListDomains", path: "/v2/domains", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists blueprint configurations for a Amazon DataZone environment.
    public func listEnvironmentBlueprintConfigurations(_ input: ListEnvironmentBlueprintConfigurationsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListEnvironmentBlueprintConfigurationsOutput> {
        return self.client.execute(operation: "ListEnvironmentBlueprintConfigurations", path: "/v2/domains/{domainIdentifier}/environment-blueprint-configurations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists blueprints in an Amazon DataZone environment.
    public func listEnvironmentBlueprints(_ input: ListEnvironmentBlueprintsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListEnvironmentBlueprintsOutput> {
        return self.client.execute(operation: "ListEnvironmentBlueprints", path: "/v2/domains/{domainIdentifier}/environment-blueprints", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists Amazon DataZone environment profiles.
    public func listEnvironmentProfiles(_ input: ListEnvironmentProfilesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListEnvironmentProfilesOutput> {
        return self.client.execute(operation: "ListEnvironmentProfiles", path: "/v2/domains/{domainIdentifier}/environment-profiles", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists Amazon DataZone environments.
    public func listEnvironments(_ input: ListEnvironmentsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListEnvironmentsOutput> {
        return self.client.execute(operation: "ListEnvironments", path: "/v2/domains/{domainIdentifier}/environments", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all Amazon DataZone notifications.
    public func listNotifications(_ input: ListNotificationsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListNotificationsOutput> {
        return self.client.execute(operation: "ListNotifications", path: "/v2/domains/{domainIdentifier}/notifications", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all members of the specified project.
    public func listProjectMemberships(_ input: ListProjectMembershipsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListProjectMembershipsOutput> {
        return self.client.execute(operation: "ListProjectMemberships", path: "/v2/domains/{domainIdentifier}/projects/{projectIdentifier}/memberships", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists Amazon DataZone projects.
    public func listProjects(_ input: ListProjectsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListProjectsOutput> {
        return self.client.execute(operation: "ListProjects", path: "/v2/domains/{domainIdentifier}/projects", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists subscription grants.
    public func listSubscriptionGrants(_ input: ListSubscriptionGrantsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSubscriptionGrantsOutput> {
        return self.client.execute(operation: "ListSubscriptionGrants", path: "/v2/domains/{domainIdentifier}/subscription-grants", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists Amazon DataZone subscription requests.
    public func listSubscriptionRequests(_ input: ListSubscriptionRequestsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSubscriptionRequestsOutput> {
        return self.client.execute(operation: "ListSubscriptionRequests", path: "/v2/domains/{domainIdentifier}/subscription-requests", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists subscription targets in Amazon DataZone.
    public func listSubscriptionTargets(_ input: ListSubscriptionTargetsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSubscriptionTargetsOutput> {
        return self.client.execute(operation: "ListSubscriptionTargets", path: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists subscriptions in Amazon DataZone.
    public func listSubscriptions(_ input: ListSubscriptionsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSubscriptionsOutput> {
        return self.client.execute(operation: "ListSubscriptions", path: "/v2/domains/{domainIdentifier}/subscriptions", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists tags for the specified resource in Amazon DataZone.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceResponse> {
        return self.client.execute(operation: "ListTagsForResource", path: "/tags/{resourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Writes the configuration for the specified environment blueprint in Amazon DataZone.
    public func putEnvironmentBlueprintConfiguration(_ input: PutEnvironmentBlueprintConfigurationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutEnvironmentBlueprintConfigurationOutput> {
        return self.client.execute(operation: "PutEnvironmentBlueprintConfiguration", path: "/v2/domains/{domainIdentifier}/environment-blueprint-configurations/{environmentBlueprintIdentifier}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Rejects automatically generated business-friendly metadata for your Amazon DataZone assets.
    public func rejectPredictions(_ input: RejectPredictionsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RejectPredictionsOutput> {
        return self.client.execute(operation: "RejectPredictions", path: "/v2/domains/{domainIdentifier}/assets/{identifier}/reject-predictions", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Rejects the specified subscription request.
    public func rejectSubscriptionRequest(_ input: RejectSubscriptionRequestInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RejectSubscriptionRequestOutput> {
        return self.client.execute(operation: "RejectSubscriptionRequest", path: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}/reject", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Revokes a specified subscription in Amazon DataZone.
    public func revokeSubscription(_ input: RevokeSubscriptionInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RevokeSubscriptionOutput> {
        return self.client.execute(operation: "RevokeSubscription", path: "/v2/domains/{domainIdentifier}/subscriptions/{identifier}/revoke", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Searches for assets in Amazon DataZone.
    public func search(_ input: SearchInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SearchOutput> {
        return self.client.execute(operation: "Search", path: "/v2/domains/{domainIdentifier}/search", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Searches group profiles in Amazon DataZone.
    public func searchGroupProfiles(_ input: SearchGroupProfilesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SearchGroupProfilesOutput> {
        return self.client.execute(operation: "SearchGroupProfiles", path: "/v2/domains/{domainIdentifier}/search-group-profiles", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Searches listings in Amazon DataZone.
    public func searchListings(_ input: SearchListingsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SearchListingsOutput> {
        return self.client.execute(operation: "SearchListings", path: "/v2/domains/{domainIdentifier}/listings/search", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Searches for types in Amazon DataZone.
    public func searchTypes(_ input: SearchTypesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SearchTypesOutput> {
        return self.client.execute(operation: "SearchTypes", path: "/v2/domains/{domainIdentifier}/types-search", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Searches user profiles in Amazon DataZone.
    public func searchUserProfiles(_ input: SearchUserProfilesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SearchUserProfilesOutput> {
        return self.client.execute(operation: "SearchUserProfiles", path: "/v2/domains/{domainIdentifier}/search-user-profiles", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Start the run of the specified data source in Amazon DataZone.
    public func startDataSourceRun(_ input: StartDataSourceRunInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartDataSourceRunOutput> {
        return self.client.execute(operation: "StartDataSourceRun", path: "/v2/domains/{domainIdentifier}/data-sources/{dataSourceIdentifier}/runs", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Tags a resource in Amazon DataZone.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceResponse> {
        return self.client.execute(operation: "TagResource", path: "/tags/{resourceArn}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Untags a resource in Amazon DataZone.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceResponse> {
        return self.client.execute(operation: "UntagResource", path: "/tags/{resourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the specified data source in Amazon DataZone.
    public func updateDataSource(_ input: UpdateDataSourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateDataSourceOutput> {
        return self.client.execute(operation: "UpdateDataSource", path: "/v2/domains/{domainIdentifier}/data-sources/{identifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a Amazon DataZone domain.
    public func updateDomain(_ input: UpdateDomainInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateDomainOutput> {
        return self.client.execute(operation: "UpdateDomain", path: "/v2/domains/{identifier}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the specified environment in Amazon DataZone.
    public func updateEnvironment(_ input: UpdateEnvironmentInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateEnvironmentOutput> {
        return self.client.execute(operation: "UpdateEnvironment", path: "/v2/domains/{domainIdentifier}/environments/{identifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the specified environment profile in Amazon DataZone.
    public func updateEnvironmentProfile(_ input: UpdateEnvironmentProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateEnvironmentProfileOutput> {
        return self.client.execute(operation: "UpdateEnvironmentProfile", path: "/v2/domains/{domainIdentifier}/environment-profiles/{identifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the business glossary in Amazon DataZone.
    public func updateGlossary(_ input: UpdateGlossaryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateGlossaryOutput> {
        return self.client.execute(operation: "UpdateGlossary", path: "/v2/domains/{domainIdentifier}/glossaries/{identifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a business glossary term in Amazon DataZone.
    public func updateGlossaryTerm(_ input: UpdateGlossaryTermInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateGlossaryTermOutput> {
        return self.client.execute(operation: "UpdateGlossaryTerm", path: "/v2/domains/{domainIdentifier}/glossary-terms/{identifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the specified group profile in Amazon DataZone.
    public func updateGroupProfile(_ input: UpdateGroupProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateGroupProfileOutput> {
        return self.client.execute(operation: "UpdateGroupProfile", path: "/v2/domains/{domainIdentifier}/group-profiles/{groupIdentifier}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the specified project in Amazon DataZone.
    public func updateProject(_ input: UpdateProjectInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateProjectOutput> {
        return self.client.execute(operation: "UpdateProject", path: "/v2/domains/{domainIdentifier}/projects/{identifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the status of the specified subscription grant status in Amazon DataZone.
    public func updateSubscriptionGrantStatus(_ input: UpdateSubscriptionGrantStatusInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateSubscriptionGrantStatusOutput> {
        return self.client.execute(operation: "UpdateSubscriptionGrantStatus", path: "/v2/domains/{domainIdentifier}/subscription-grants/{identifier}/status/{assetIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a specified subscription request in Amazon DataZone.
    public func updateSubscriptionRequest(_ input: UpdateSubscriptionRequestInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateSubscriptionRequestOutput> {
        return self.client.execute(operation: "UpdateSubscriptionRequest", path: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the specified subscription target in Amazon DataZone.
    public func updateSubscriptionTarget(_ input: UpdateSubscriptionTargetInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateSubscriptionTargetOutput> {
        return self.client.execute(operation: "UpdateSubscriptionTarget", path: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets/{identifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the specified user profile in Amazon DataZone.
    public func updateUserProfile(_ input: UpdateUserProfileInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateUserProfileOutput> {
        return self.client.execute(operation: "UpdateUserProfile", path: "/v2/domains/{domainIdentifier}/user-profiles/{userIdentifier}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension DataZone {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: DataZone, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension DataZone {
    /// Lists data source run activities.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDataSourceRunActivitiesPaginator<Result>(
        _ input: ListDataSourceRunActivitiesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDataSourceRunActivitiesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDataSourceRunActivities,
            inputKey: \ListDataSourceRunActivitiesInput.nextToken,
            outputKey: \ListDataSourceRunActivitiesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDataSourceRunActivitiesPaginator(
        _ input: ListDataSourceRunActivitiesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDataSourceRunActivitiesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDataSourceRunActivities,
            inputKey: \ListDataSourceRunActivitiesInput.nextToken,
            outputKey: \ListDataSourceRunActivitiesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists data source runs in Amazon DataZone.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDataSourceRunsPaginator<Result>(
        _ input: ListDataSourceRunsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDataSourceRunsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDataSourceRuns,
            inputKey: \ListDataSourceRunsInput.nextToken,
            outputKey: \ListDataSourceRunsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDataSourceRunsPaginator(
        _ input: ListDataSourceRunsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDataSourceRunsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDataSourceRuns,
            inputKey: \ListDataSourceRunsInput.nextToken,
            outputKey: \ListDataSourceRunsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists data sources in Amazon DataZone.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDataSourcesPaginator<Result>(
        _ input: ListDataSourcesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDataSourcesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDataSources,
            inputKey: \ListDataSourcesInput.nextToken,
            outputKey: \ListDataSourcesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDataSourcesPaginator(
        _ input: ListDataSourcesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDataSourcesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDataSources,
            inputKey: \ListDataSourcesInput.nextToken,
            outputKey: \ListDataSourcesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists Amazon DataZone domains.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDomainsPaginator<Result>(
        _ input: ListDomainsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDomainsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDomains,
            inputKey: \ListDomainsInput.nextToken,
            outputKey: \ListDomainsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDomainsPaginator(
        _ input: ListDomainsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDomainsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDomains,
            inputKey: \ListDomainsInput.nextToken,
            outputKey: \ListDomainsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists blueprint configurations for a Amazon DataZone environment.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listEnvironmentBlueprintConfigurationsPaginator<Result>(
        _ input: ListEnvironmentBlueprintConfigurationsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListEnvironmentBlueprintConfigurationsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listEnvironmentBlueprintConfigurations,
            inputKey: \ListEnvironmentBlueprintConfigurationsInput.nextToken,
            outputKey: \ListEnvironmentBlueprintConfigurationsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listEnvironmentBlueprintConfigurationsPaginator(
        _ input: ListEnvironmentBlueprintConfigurationsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListEnvironmentBlueprintConfigurationsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listEnvironmentBlueprintConfigurations,
            inputKey: \ListEnvironmentBlueprintConfigurationsInput.nextToken,
            outputKey: \ListEnvironmentBlueprintConfigurationsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists blueprints in an Amazon DataZone environment.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listEnvironmentBlueprintsPaginator<Result>(
        _ input: ListEnvironmentBlueprintsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListEnvironmentBlueprintsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listEnvironmentBlueprints,
            inputKey: \ListEnvironmentBlueprintsInput.nextToken,
            outputKey: \ListEnvironmentBlueprintsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listEnvironmentBlueprintsPaginator(
        _ input: ListEnvironmentBlueprintsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListEnvironmentBlueprintsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listEnvironmentBlueprints,
            inputKey: \ListEnvironmentBlueprintsInput.nextToken,
            outputKey: \ListEnvironmentBlueprintsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists Amazon DataZone environment profiles.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listEnvironmentProfilesPaginator<Result>(
        _ input: ListEnvironmentProfilesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListEnvironmentProfilesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listEnvironmentProfiles,
            inputKey: \ListEnvironmentProfilesInput.nextToken,
            outputKey: \ListEnvironmentProfilesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listEnvironmentProfilesPaginator(
        _ input: ListEnvironmentProfilesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListEnvironmentProfilesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listEnvironmentProfiles,
            inputKey: \ListEnvironmentProfilesInput.nextToken,
            outputKey: \ListEnvironmentProfilesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists Amazon DataZone environments.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listEnvironmentsPaginator<Result>(
        _ input: ListEnvironmentsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListEnvironmentsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listEnvironments,
            inputKey: \ListEnvironmentsInput.nextToken,
            outputKey: \ListEnvironmentsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listEnvironmentsPaginator(
        _ input: ListEnvironmentsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListEnvironmentsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listEnvironments,
            inputKey: \ListEnvironmentsInput.nextToken,
            outputKey: \ListEnvironmentsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists all Amazon DataZone notifications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listNotificationsPaginator<Result>(
        _ input: ListNotificationsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListNotificationsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listNotifications,
            inputKey: \ListNotificationsInput.nextToken,
            outputKey: \ListNotificationsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listNotificationsPaginator(
        _ input: ListNotificationsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListNotificationsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listNotifications,
            inputKey: \ListNotificationsInput.nextToken,
            outputKey: \ListNotificationsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists all members of the specified project.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listProjectMembershipsPaginator<Result>(
        _ input: ListProjectMembershipsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListProjectMembershipsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listProjectMemberships,
            inputKey: \ListProjectMembershipsInput.nextToken,
            outputKey: \ListProjectMembershipsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listProjectMembershipsPaginator(
        _ input: ListProjectMembershipsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListProjectMembershipsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listProjectMemberships,
            inputKey: \ListProjectMembershipsInput.nextToken,
            outputKey: \ListProjectMembershipsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists Amazon DataZone projects.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listProjectsPaginator<Result>(
        _ input: ListProjectsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListProjectsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listProjects,
            inputKey: \ListProjectsInput.nextToken,
            outputKey: \ListProjectsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listProjectsPaginator(
        _ input: ListProjectsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListProjectsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listProjects,
            inputKey: \ListProjectsInput.nextToken,
            outputKey: \ListProjectsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists subscription grants.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSubscriptionGrantsPaginator<Result>(
        _ input: ListSubscriptionGrantsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSubscriptionGrantsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listSubscriptionGrants,
            inputKey: \ListSubscriptionGrantsInput.nextToken,
            outputKey: \ListSubscriptionGrantsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSubscriptionGrantsPaginator(
        _ input: ListSubscriptionGrantsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSubscriptionGrantsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listSubscriptionGrants,
            inputKey: \ListSubscriptionGrantsInput.nextToken,
            outputKey: \ListSubscriptionGrantsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists Amazon DataZone subscription requests.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSubscriptionRequestsPaginator<Result>(
        _ input: ListSubscriptionRequestsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSubscriptionRequestsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listSubscriptionRequests,
            inputKey: \ListSubscriptionRequestsInput.nextToken,
            outputKey: \ListSubscriptionRequestsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSubscriptionRequestsPaginator(
        _ input: ListSubscriptionRequestsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSubscriptionRequestsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listSubscriptionRequests,
            inputKey: \ListSubscriptionRequestsInput.nextToken,
            outputKey: \ListSubscriptionRequestsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists subscription targets in Amazon DataZone.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSubscriptionTargetsPaginator<Result>(
        _ input: ListSubscriptionTargetsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSubscriptionTargetsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listSubscriptionTargets,
            inputKey: \ListSubscriptionTargetsInput.nextToken,
            outputKey: \ListSubscriptionTargetsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSubscriptionTargetsPaginator(
        _ input: ListSubscriptionTargetsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSubscriptionTargetsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listSubscriptionTargets,
            inputKey: \ListSubscriptionTargetsInput.nextToken,
            outputKey: \ListSubscriptionTargetsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists subscriptions in Amazon DataZone.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSubscriptionsPaginator<Result>(
        _ input: ListSubscriptionsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSubscriptionsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listSubscriptions,
            inputKey: \ListSubscriptionsInput.nextToken,
            outputKey: \ListSubscriptionsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSubscriptionsPaginator(
        _ input: ListSubscriptionsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSubscriptionsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listSubscriptions,
            inputKey: \ListSubscriptionsInput.nextToken,
            outputKey: \ListSubscriptionsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Searches for assets in Amazon DataZone.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchPaginator<Result>(
        _ input: SearchInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.search,
            inputKey: \SearchInput.nextToken,
            outputKey: \SearchOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchPaginator(
        _ input: SearchInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.search,
            inputKey: \SearchInput.nextToken,
            outputKey: \SearchOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Searches group profiles in Amazon DataZone.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchGroupProfilesPaginator<Result>(
        _ input: SearchGroupProfilesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchGroupProfilesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.searchGroupProfiles,
            inputKey: \SearchGroupProfilesInput.nextToken,
            outputKey: \SearchGroupProfilesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchGroupProfilesPaginator(
        _ input: SearchGroupProfilesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchGroupProfilesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.searchGroupProfiles,
            inputKey: \SearchGroupProfilesInput.nextToken,
            outputKey: \SearchGroupProfilesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Searches listings in Amazon DataZone.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchListingsPaginator<Result>(
        _ input: SearchListingsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchListingsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.searchListings,
            inputKey: \SearchListingsInput.nextToken,
            outputKey: \SearchListingsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchListingsPaginator(
        _ input: SearchListingsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchListingsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.searchListings,
            inputKey: \SearchListingsInput.nextToken,
            outputKey: \SearchListingsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Searches for types in Amazon DataZone.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchTypesPaginator<Result>(
        _ input: SearchTypesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchTypesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.searchTypes,
            inputKey: \SearchTypesInput.nextToken,
            outputKey: \SearchTypesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchTypesPaginator(
        _ input: SearchTypesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchTypesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.searchTypes,
            inputKey: \SearchTypesInput.nextToken,
            outputKey: \SearchTypesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Searches user profiles in Amazon DataZone.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchUserProfilesPaginator<Result>(
        _ input: SearchUserProfilesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchUserProfilesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.searchUserProfiles,
            inputKey: \SearchUserProfilesInput.nextToken,
            outputKey: \SearchUserProfilesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchUserProfilesPaginator(
        _ input: SearchUserProfilesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchUserProfilesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.searchUserProfiles,
            inputKey: \SearchUserProfilesInput.nextToken,
            outputKey: \SearchUserProfilesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension DataZone.ListDataSourceRunActivitiesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListDataSourceRunActivitiesInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            identifier: self.identifier,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension DataZone.ListDataSourceRunsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListDataSourceRunsInput {
        return .init(
            dataSourceIdentifier: self.dataSourceIdentifier,
            domainIdentifier: self.domainIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension DataZone.ListDataSourcesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListDataSourcesInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            environmentIdentifier: self.environmentIdentifier,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            projectIdentifier: self.projectIdentifier,
            status: self.status,
            type: self.type
        )
    }
}

extension DataZone.ListDomainsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListDomainsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension DataZone.ListEnvironmentBlueprintConfigurationsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListEnvironmentBlueprintConfigurationsInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension DataZone.ListEnvironmentBlueprintsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListEnvironmentBlueprintsInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            managed: self.managed,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension DataZone.ListEnvironmentProfilesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListEnvironmentProfilesInput {
        return .init(
            awsAccountId: self.awsAccountId,
            awsAccountRegion: self.awsAccountRegion,
            domainIdentifier: self.domainIdentifier,
            environmentBlueprintIdentifier: self.environmentBlueprintIdentifier,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            projectIdentifier: self.projectIdentifier
        )
    }
}

extension DataZone.ListEnvironmentsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListEnvironmentsInput {
        return .init(
            awsAccountId: self.awsAccountId,
            awsAccountRegion: self.awsAccountRegion,
            domainIdentifier: self.domainIdentifier,
            environmentBlueprintIdentifier: self.environmentBlueprintIdentifier,
            environmentProfileIdentifier: self.environmentProfileIdentifier,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            projectIdentifier: self.projectIdentifier,
            provider: self.provider,
            status: self.status
        )
    }
}

extension DataZone.ListNotificationsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListNotificationsInput {
        return .init(
            afterTimestamp: self.afterTimestamp,
            beforeTimestamp: self.beforeTimestamp,
            domainIdentifier: self.domainIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            subjects: self.subjects,
            taskStatus: self.taskStatus,
            type: self.type
        )
    }
}

extension DataZone.ListProjectMembershipsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListProjectMembershipsInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            projectIdentifier: self.projectIdentifier,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

extension DataZone.ListProjectsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListProjectsInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            groupIdentifier: self.groupIdentifier,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            userIdentifier: self.userIdentifier
        )
    }
}

extension DataZone.ListSubscriptionGrantsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListSubscriptionGrantsInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            environmentId: self.environmentId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            subscribedListingId: self.subscribedListingId,
            subscriptionId: self.subscriptionId,
            subscriptionTargetId: self.subscriptionTargetId
        )
    }
}

extension DataZone.ListSubscriptionRequestsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListSubscriptionRequestsInput {
        return .init(
            approverProjectId: self.approverProjectId,
            domainIdentifier: self.domainIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            owningProjectId: self.owningProjectId,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            status: self.status,
            subscribedListingId: self.subscribedListingId
        )
    }
}

extension DataZone.ListSubscriptionTargetsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListSubscriptionTargetsInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            environmentIdentifier: self.environmentIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

extension DataZone.ListSubscriptionsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.ListSubscriptionsInput {
        return .init(
            approverProjectId: self.approverProjectId,
            domainIdentifier: self.domainIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            owningProjectId: self.owningProjectId,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            status: self.status,
            subscribedListingId: self.subscribedListingId,
            subscriptionRequestIdentifier: self.subscriptionRequestIdentifier
        )
    }
}

extension DataZone.SearchGroupProfilesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.SearchGroupProfilesInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            groupType: self.groupType,
            maxResults: self.maxResults,
            nextToken: token,
            searchText: self.searchText
        )
    }
}

extension DataZone.SearchInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.SearchInput {
        return .init(
            additionalAttributes: self.additionalAttributes,
            domainIdentifier: self.domainIdentifier,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owningProjectIdentifier: self.owningProjectIdentifier,
            searchIn: self.searchIn,
            searchScope: self.searchScope,
            searchText: self.searchText,
            sort: self.sort
        )
    }
}

extension DataZone.SearchListingsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.SearchListingsInput {
        return .init(
            additionalAttributes: self.additionalAttributes,
            domainIdentifier: self.domainIdentifier,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            searchIn: self.searchIn,
            searchText: self.searchText,
            sort: self.sort
        )
    }
}

extension DataZone.SearchTypesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.SearchTypesInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            filters: self.filters,
            managed: self.managed,
            maxResults: self.maxResults,
            nextToken: token,
            searchIn: self.searchIn,
            searchScope: self.searchScope,
            searchText: self.searchText,
            sort: self.sort
        )
    }
}

extension DataZone.SearchUserProfilesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DataZone.SearchUserProfilesInput {
        return .init(
            domainIdentifier: self.domainIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            searchText: self.searchText,
            userType: self.userType
        )
    }
}
