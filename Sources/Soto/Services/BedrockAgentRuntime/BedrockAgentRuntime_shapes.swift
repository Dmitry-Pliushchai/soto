//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgentRuntime {
    // MARK: Enums

    public enum CreationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case overridden = "OVERRIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum InvocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case finish = "FINISH"
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum PromptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBaseResponseGeneration = "KNOWLEDGE_BASE_RESPONSE_GENERATION"
        case orchestration = "ORCHESTRATION"
        case postProcessing = "POST_PROCESSING"
        case preProcessing = "PRE_PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum RetrievalResultLocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum RetrieveAndGenerateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum Source: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case knowledgeBase = "KNOWLEDGE_BASE"
        case parser = "PARSER"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionGroup = "ACTION_GROUP"
        case askUser = "ASK_USER"
        case finish = "FINISH"
        case knowledgeBase = "KNOWLEDGE_BASE"
        case reprompt = "REPROMPT"
        public var description: String { return self.rawValue }
    }

    public enum OrchestrationTrace: AWSDecodableShape, Sendable {
        case invocationInput(InvocationInput)
        case modelInvocationInput(ModelInvocationInput)
        case observation(Observation)
        case rationale(Rationale)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .invocationInput:
                let value = try container.decode(InvocationInput.self, forKey: .invocationInput)
                self = .invocationInput(value)
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .observation:
                let value = try container.decode(Observation.self, forKey: .observation)
                self = .observation(value)
            case .rationale:
                let value = try container.decode(Rationale.self, forKey: .rationale)
                self = .rationale(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invocationInput = "invocationInput"
            case modelInvocationInput = "modelInvocationInput"
            case observation = "observation"
            case rationale = "rationale"
        }
    }

    public enum PostProcessingTrace: AWSDecodableShape, Sendable {
        case modelInvocationInput(ModelInvocationInput)
        case modelInvocationOutput(PostProcessingModelInvocationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(PostProcessingModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
        }
    }

    public enum PreProcessingTrace: AWSDecodableShape, Sendable {
        case modelInvocationInput(ModelInvocationInput)
        case modelInvocationOutput(PreProcessingModelInvocationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .modelInvocationInput:
                let value = try container.decode(ModelInvocationInput.self, forKey: .modelInvocationInput)
                self = .modelInvocationInput(value)
            case .modelInvocationOutput:
                let value = try container.decode(PreProcessingModelInvocationOutput.self, forKey: .modelInvocationOutput)
                self = .modelInvocationOutput(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case modelInvocationInput = "modelInvocationInput"
            case modelInvocationOutput = "modelInvocationOutput"
        }
    }

    public enum ResponseStream: AWSDecodableShape, Sendable {
        case accessDeniedException(AccessDeniedException)
        case badGatewayException(BadGatewayException)
        case chunk(PayloadPart)
        case conflictException(ConflictException)
        case dependencyFailedException(DependencyFailedException)
        case internalServerException(InternalServerException)
        case resourceNotFoundException(ResourceNotFoundException)
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        case throttlingException(ThrottlingException)
        case trace(TracePart)
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .chunk:
                let value = try container.decode(PayloadPart.self, forKey: .chunk)
                self = .chunk(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .trace:
                let value = try container.decode(TracePart.self, forKey: .trace)
                self = .trace(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case badGatewayException = "badGatewayException"
            case chunk = "chunk"
            case conflictException = "conflictException"
            case dependencyFailedException = "dependencyFailedException"
            case internalServerException = "internalServerException"
            case resourceNotFoundException = "resourceNotFoundException"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case trace = "trace"
            case validationException = "validationException"
        }
    }

    public enum Trace: AWSDecodableShape, Sendable {
        case failureTrace(FailureTrace)
        case orchestrationTrace(OrchestrationTrace)
        case postProcessingTrace(PostProcessingTrace)
        case preProcessingTrace(PreProcessingTrace)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .failureTrace:
                let value = try container.decode(FailureTrace.self, forKey: .failureTrace)
                self = .failureTrace(value)
            case .orchestrationTrace:
                let value = try container.decode(OrchestrationTrace.self, forKey: .orchestrationTrace)
                self = .orchestrationTrace(value)
            case .postProcessingTrace:
                let value = try container.decode(PostProcessingTrace.self, forKey: .postProcessingTrace)
                self = .postProcessingTrace(value)
            case .preProcessingTrace:
                let value = try container.decode(PreProcessingTrace.self, forKey: .preProcessingTrace)
                self = .preProcessingTrace(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case failureTrace = "failureTrace"
            case orchestrationTrace = "orchestrationTrace"
            case postProcessingTrace = "postProcessingTrace"
            case preProcessingTrace = "preProcessingTrace"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ActionGroupInvocationInput: AWSDecodableShape {
        public let actionGroupName: String?
        public let apiPath: String?
        public let parameters: [Parameter]?
        public let requestBody: RequestBody?
        public let verb: String?

        public init(actionGroupName: String? = nil, apiPath: String? = nil, parameters: [Parameter]? = nil, requestBody: RequestBody? = nil, verb: String? = nil) {
            self.actionGroupName = actionGroupName
            self.apiPath = apiPath
            self.parameters = parameters
            self.requestBody = requestBody
            self.verb = verb
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupName = "actionGroupName"
            case apiPath = "apiPath"
            case parameters = "parameters"
            case requestBody = "requestBody"
            case verb = "verb"
        }
    }

    public struct ActionGroupInvocationOutput: AWSDecodableShape {
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct Attribution: AWSDecodableShape {
        public let citations: [Citation]?

        public init(citations: [Citation]? = nil) {
            self.citations = citations
        }

        private enum CodingKeys: String, CodingKey {
            case citations = "citations"
        }
    }

    public struct BadGatewayException: AWSDecodableShape {
        public let message: String?
        public let resourceName: String?

        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct Citation: AWSDecodableShape {
        public let generatedResponsePart: GeneratedResponsePart?
        public let retrievedReferences: [RetrievedReference]?

        public init(generatedResponsePart: GeneratedResponsePart? = nil, retrievedReferences: [RetrievedReference]? = nil) {
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }

        private enum CodingKeys: String, CodingKey {
            case generatedResponsePart = "generatedResponsePart"
            case retrievedReferences = "retrievedReferences"
        }
    }

    public struct ConflictException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DependencyFailedException: AWSDecodableShape {
        public let message: String?
        public let resourceName: String?

        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct FailureTrace: AWSDecodableShape {
        public let failureReason: String?
        public let traceId: String?

        public init(failureReason: String? = nil, traceId: String? = nil) {
            self.failureReason = failureReason
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "failureReason"
            case traceId = "traceId"
        }
    }

    public struct FinalResponse: AWSDecodableShape {
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct GeneratedResponsePart: AWSDecodableShape {
        public let textResponsePart: TextResponsePart?

        public init(textResponsePart: TextResponsePart? = nil) {
            self.textResponsePart = textResponsePart
        }

        private enum CodingKeys: String, CodingKey {
            case textResponsePart = "textResponsePart"
        }
    }

    public struct InferenceConfiguration: AWSDecodableShape {
        public let maximumLength: Int?
        public let stopSequences: [String]?
        public let temperature: Float?
        public let topK: Int?
        public let topP: Float?

        public init(maximumLength: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topK: Int? = nil, topP: Float? = nil) {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topK = topK
            self.topP = topP
        }

        private enum CodingKeys: String, CodingKey {
            case maximumLength = "maximumLength"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topK = "topK"
            case topP = "topP"
        }
    }

    public struct InternalServerException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvocationInput: AWSDecodableShape {
        public let actionGroupInvocationInput: ActionGroupInvocationInput?
        public let invocationType: InvocationType?
        public let knowledgeBaseLookupInput: KnowledgeBaseLookupInput?
        public let traceId: String?

        public init(actionGroupInvocationInput: ActionGroupInvocationInput? = nil, invocationType: InvocationType? = nil, knowledgeBaseLookupInput: KnowledgeBaseLookupInput? = nil, traceId: String? = nil) {
            self.actionGroupInvocationInput = actionGroupInvocationInput
            self.invocationType = invocationType
            self.knowledgeBaseLookupInput = knowledgeBaseLookupInput
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupInvocationInput = "actionGroupInvocationInput"
            case invocationType = "invocationType"
            case knowledgeBaseLookupInput = "knowledgeBaseLookupInput"
            case traceId = "traceId"
        }
    }

    public struct InvokeAgentRequest: AWSEncodableShape {
        /// Identifier for Agent Alias
        public let agentAliasId: String
        /// Identifier for Agent
        public let agentId: String
        /// Enable agent trace events for improved debugging
        public let enableTrace: Bool?
        /// End current session
        public let endSession: Bool?
        /// Input data in the format specified in the Content-Type request header.
        public let inputText: String
        /// Identifier used for the current session
        public let sessionId: String
        /// Session state passed by customer. Base64 encoded json string representation of SessionState.
        public let sessionState: SessionState?

        public init(agentAliasId: String, agentId: String, enableTrace: Bool? = nil, endSession: Bool? = nil, inputText: String, sessionId: String, sessionState: SessionState? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.enableTrace = enableTrace
            self.endSession = endSession
            self.inputText = inputText
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentAliasId, key: "agentAliasId")
            request.encodePath(self.agentId, key: "agentId")
            try container.encodeIfPresent(self.enableTrace, forKey: .enableTrace)
            try container.encodeIfPresent(self.endSession, forKey: .endSession)
            try container.encode(self.inputText, forKey: .inputText)
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encodeIfPresent(self.sessionState, forKey: .sessionState)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, max: 10)
            try self.validate(self.agentAliasId, name: "agentAliasId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.agentId, name: "agentId", parent: name, max: 10)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.inputText, name: "inputText", parent: name, max: 25000000)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case enableTrace = "enableTrace"
            case endSession = "endSession"
            case inputText = "inputText"
            case sessionState = "sessionState"
        }
    }

    public struct InvokeAgentResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Inference response from the model in the format specified in the Content-Type response header.
        public let completion: AWSEventStream<ResponseStream>
        /// streaming response mimetype of the model
        public let contentType: String
        /// streaming response mimetype of the model
        public let sessionId: String

        public init(completion: AWSEventStream<ResponseStream>, contentType: String, sessionId: String) {
            self.completion = completion
            self.contentType = contentType
            self.sessionId = sessionId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.completion = try container.decode(AWSEventStream<ResponseStream>.self)
            self.contentType = try response.decodeHeader(String.self, key: "x-amzn-bedrock-agent-content-type")
            self.sessionId = try response.decodeHeader(String.self, key: "x-amz-bedrock-agent-session-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct KnowledgeBaseLookupInput: AWSDecodableShape {
        public let knowledgeBaseId: String?
        public let text: String?

        public init(knowledgeBaseId: String? = nil, text: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case text = "text"
        }
    }

    public struct KnowledgeBaseLookupOutput: AWSDecodableShape {
        public let retrievedReferences: [RetrievedReference]?

        public init(retrievedReferences: [RetrievedReference]? = nil) {
            self.retrievedReferences = retrievedReferences
        }

        private enum CodingKeys: String, CodingKey {
            case retrievedReferences = "retrievedReferences"
        }
    }

    public struct KnowledgeBaseQuery: AWSEncodableShape {
        /// Knowledge base input query in text
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct KnowledgeBaseRetrievalConfiguration: AWSEncodableShape {
        public let vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration

        public init(vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration) {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct KnowledgeBaseRetrievalResult: AWSDecodableShape {
        public let content: RetrievalResultContent
        public let location: RetrievalResultLocation?
        /// The relevance score of a result.
        public let score: Double?

        public init(content: RetrievalResultContent, location: RetrievalResultLocation? = nil, score: Double? = nil) {
            self.content = content
            self.location = location
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case location = "location"
            case score = "score"
        }
    }

    public struct KnowledgeBaseRetrieveAndGenerateConfiguration: AWSEncodableShape {
        public let knowledgeBaseId: String
        public let modelArn: String

        public init(knowledgeBaseId: String, modelArn: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 1011)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 20)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case modelArn = "modelArn"
        }
    }

    public struct KnowledgeBaseVectorSearchConfiguration: AWSEncodableShape {
        /// Top-K results to retrieve from knowledge base.
        public let numberOfResults: Int

        public init(numberOfResults: Int) {
            self.numberOfResults = numberOfResults
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfResults = "numberOfResults"
        }
    }

    public struct ModelInvocationInput: AWSDecodableShape {
        public let inferenceConfiguration: InferenceConfiguration?
        public let overrideLambda: String?
        public let parserMode: CreationMode?
        public let promptCreationMode: CreationMode?
        public let text: String?
        public let traceId: String?
        public let type: PromptType?

        public init(inferenceConfiguration: InferenceConfiguration? = nil, overrideLambda: String? = nil, parserMode: CreationMode? = nil, promptCreationMode: CreationMode? = nil, text: String? = nil, traceId: String? = nil, type: PromptType? = nil) {
            self.inferenceConfiguration = inferenceConfiguration
            self.overrideLambda = overrideLambda
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.text = text
            self.traceId = traceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceConfiguration = "inferenceConfiguration"
            case overrideLambda = "overrideLambda"
            case parserMode = "parserMode"
            case promptCreationMode = "promptCreationMode"
            case text = "text"
            case traceId = "traceId"
            case type = "type"
        }
    }

    public struct Observation: AWSDecodableShape {
        public let actionGroupInvocationOutput: ActionGroupInvocationOutput?
        public let finalResponse: FinalResponse?
        public let knowledgeBaseLookupOutput: KnowledgeBaseLookupOutput?
        public let repromptResponse: RepromptResponse?
        public let traceId: String?
        public let type: `Type`?

        public init(actionGroupInvocationOutput: ActionGroupInvocationOutput? = nil, finalResponse: FinalResponse? = nil, knowledgeBaseLookupOutput: KnowledgeBaseLookupOutput? = nil, repromptResponse: RepromptResponse? = nil, traceId: String? = nil, type: `Type`? = nil) {
            self.actionGroupInvocationOutput = actionGroupInvocationOutput
            self.finalResponse = finalResponse
            self.knowledgeBaseLookupOutput = knowledgeBaseLookupOutput
            self.repromptResponse = repromptResponse
            self.traceId = traceId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionGroupInvocationOutput = "actionGroupInvocationOutput"
            case finalResponse = "finalResponse"
            case knowledgeBaseLookupOutput = "knowledgeBaseLookupOutput"
            case repromptResponse = "repromptResponse"
            case traceId = "traceId"
            case type = "type"
        }
    }

    public struct Parameter: AWSDecodableShape {
        /// Name of parameter
        public let name: String?
        /// Type of parameter
        public let type: String?
        /// Value of parameter
        public let value: String?

        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
            case value = "value"
        }
    }

    public struct PayloadPart: AWSDecodableShape {
        public let attribution: Attribution?
        public let bytes: AWSBase64Data?

        public init(attribution: Attribution? = nil, bytes: AWSBase64Data? = nil) {
            self.attribution = attribution
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case attribution = "attribution"
            case bytes = "bytes"
        }
    }

    public struct PostProcessingModelInvocationOutput: AWSDecodableShape {
        public let parsedResponse: PostProcessingParsedResponse?
        public let traceId: String?

        public init(parsedResponse: PostProcessingParsedResponse? = nil, traceId: String? = nil) {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case parsedResponse = "parsedResponse"
            case traceId = "traceId"
        }
    }

    public struct PostProcessingParsedResponse: AWSDecodableShape {
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct PreProcessingModelInvocationOutput: AWSDecodableShape {
        public let parsedResponse: PreProcessingParsedResponse?
        public let traceId: String?

        public init(parsedResponse: PreProcessingParsedResponse? = nil, traceId: String? = nil) {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case parsedResponse = "parsedResponse"
            case traceId = "traceId"
        }
    }

    public struct PreProcessingParsedResponse: AWSDecodableShape {
        /// Boolean value
        public let isValid: Bool?
        public let rationale: String?

        public init(isValid: Bool? = nil, rationale: String? = nil) {
            self.isValid = isValid
            self.rationale = rationale
        }

        private enum CodingKeys: String, CodingKey {
            case isValid = "isValid"
            case rationale = "rationale"
        }
    }

    public struct Rationale: AWSDecodableShape {
        public let text: String?
        public let traceId: String?

        public init(text: String? = nil, traceId: String? = nil) {
            self.text = text
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case traceId = "traceId"
        }
    }

    public struct RepromptResponse: AWSDecodableShape {
        public let source: Source?
        /// Reprompt response text
        public let text: String?

        public init(source: Source? = nil, text: String? = nil) {
            self.source = source
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case text = "text"
        }
    }

    public struct RequestBody: AWSDecodableShape {
        public let content: [String: [Parameter]]?

        public init(content: [String: [Parameter]]? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct ResourceNotFoundException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct RetrievalResultContent: AWSDecodableShape {
        /// Content of a retrieval result in text
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrievalResultLocation: AWSDecodableShape {
        public let s3Location: RetrievalResultS3Location?
        public let type: RetrievalResultLocationType

        public init(s3Location: RetrievalResultS3Location? = nil, type: RetrievalResultLocationType) {
            self.s3Location = s3Location
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
            case type = "type"
        }
    }

    public struct RetrievalResultS3Location: AWSDecodableShape {
        /// URI of S3 location
        public let uri: String?

        public init(uri: String? = nil) {
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct RetrieveAndGenerateConfiguration: AWSEncodableShape {
        public let knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration?
        public let type: RetrieveAndGenerateType

        public init(knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration? = nil, type: RetrieveAndGenerateType) {
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.knowledgeBaseConfiguration?.validate(name: "\(name).knowledgeBaseConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case type = "type"
        }
    }

    public struct RetrieveAndGenerateInput: AWSEncodableShape {
        /// Customer input of the turn in text
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrieveAndGenerateOutput: AWSDecodableShape {
        /// Service response of the turn in text
        public let text: String

        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct RetrieveAndGenerateRequest: AWSEncodableShape {
        public let input: RetrieveAndGenerateInput
        public let retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration?
        public let sessionConfiguration: RetrieveAndGenerateSessionConfiguration?
        public let sessionId: String?

        public init(input: RetrieveAndGenerateInput, retrieveAndGenerateConfiguration: RetrieveAndGenerateConfiguration? = nil, sessionConfiguration: RetrieveAndGenerateSessionConfiguration? = nil, sessionId: String? = nil) {
            self.input = input
            self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
            self.sessionConfiguration = sessionConfiguration
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.retrieveAndGenerateConfiguration?.validate(name: "\(name).retrieveAndGenerateConfiguration")
            try self.sessionConfiguration?.validate(name: "\(name).sessionConfiguration")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case retrieveAndGenerateConfiguration = "retrieveAndGenerateConfiguration"
            case sessionConfiguration = "sessionConfiguration"
            case sessionId = "sessionId"
        }
    }

    public struct RetrieveAndGenerateResponse: AWSDecodableShape {
        public let citations: [Citation]?
        public let output: RetrieveAndGenerateOutput
        public let sessionId: String

        public init(citations: [Citation]? = nil, output: RetrieveAndGenerateOutput, sessionId: String) {
            self.citations = citations
            self.output = output
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case citations = "citations"
            case output = "output"
            case sessionId = "sessionId"
        }
    }

    public struct RetrieveAndGenerateSessionConfiguration: AWSEncodableShape {
        /// The KMS key arn to encrypt the customer data of the session.
        public let kmsKeyArn: String

        public init(kmsKeyArn: String) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct RetrieveRequest: AWSEncodableShape {
        public let knowledgeBaseId: String
        public let nextToken: String?
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration?
        public let retrievalQuery: KnowledgeBaseQuery

        public init(knowledgeBaseId: String, nextToken: String? = nil, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration? = nil, retrievalQuery: KnowledgeBaseQuery) {
            self.knowledgeBaseId = knowledgeBaseId
            self.nextToken = nextToken
            self.retrievalConfiguration = retrievalConfiguration
            self.retrievalQuery = retrievalQuery
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.retrievalConfiguration, forKey: .retrievalConfiguration)
            try container.encode(self.retrievalQuery, forKey: .retrievalQuery)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case retrievalConfiguration = "retrievalConfiguration"
            case retrievalQuery = "retrievalQuery"
        }
    }

    public struct RetrieveResponse: AWSDecodableShape {
        public let nextToken: String?
        public let retrievalResults: [KnowledgeBaseRetrievalResult]

        public init(nextToken: String? = nil, retrievalResults: [KnowledgeBaseRetrievalResult]) {
            self.nextToken = nextToken
            self.retrievalResults = retrievalResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case retrievalResults = "retrievalResults"
        }
    }

    public struct RetrievedReference: AWSDecodableShape {
        public let content: RetrievalResultContent?
        public let location: RetrievalResultLocation?

        public init(content: RetrievalResultContent? = nil, location: RetrievalResultLocation? = nil) {
            self.content = content
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case location = "location"
        }
    }

    public struct ServiceQuotaExceededException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct SessionState: AWSEncodableShape {
        /// Prompt Session Attributes
        public let promptSessionAttributes: [String: String]?
        /// Session Attributes
        public let sessionAttributes: [String: String]?

        public init(promptSessionAttributes: [String: String]? = nil, sessionAttributes: [String: String]? = nil) {
            self.promptSessionAttributes = promptSessionAttributes
            self.sessionAttributes = sessionAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case promptSessionAttributes = "promptSessionAttributes"
            case sessionAttributes = "sessionAttributes"
        }
    }

    public struct Span: AWSDecodableShape {
        /// End of span
        public let end: Int?
        /// Start of span
        public let start: Int?

        public init(end: Int? = nil, start: Int? = nil) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct TextResponsePart: AWSDecodableShape {
        public let span: Span?
        /// Response part in text
        public let text: String?

        public init(span: Span? = nil, text: String? = nil) {
            self.span = span
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case span = "span"
            case text = "text"
        }
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TracePart: AWSDecodableShape {
        public let agentAliasId: String?
        public let agentId: String?
        public let sessionId: String?
        public let trace: Trace?

        public init(agentAliasId: String? = nil, agentId: String? = nil, sessionId: String? = nil, trace: Trace? = nil) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.sessionId = sessionId
            self.trace = trace
        }

        private enum CodingKeys: String, CodingKey {
            case agentAliasId = "agentAliasId"
            case agentId = "agentId"
            case sessionId = "sessionId"
            case trace = "trace"
        }
    }

    public struct ValidationException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgentRuntime
public struct BedrockAgentRuntimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badGatewayException = "BadGatewayException"
        case conflictException = "ConflictException"
        case dependencyFailedException = "DependencyFailedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgentRuntime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// This exception is thrown when a request is denied per access permissions
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// This exception is thrown when a request fails due to dependency like Lambda, Bedrock, STS resource
    public static var badGatewayException: Self { .init(.badGatewayException) }
    /// This exception is thrown when there is a conflict performing an operation
    public static var conflictException: Self { .init(.conflictException) }
    /// This exception is thrown when a request fails due to dependency like Lambda, Bedrock, STS resource due to a customer fault (i.e. bad configuration)
    public static var dependencyFailedException: Self { .init(.dependencyFailedException) }
    /// This exception is thrown if there was an unexpected error during processing of request
    public static var internalServerException: Self { .init(.internalServerException) }
    /// This exception is thrown when a resource referenced by the operation does not exist
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// This exception is thrown when a request is made beyond the service quota
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// This exception is thrown when the number of requests exceeds the limit
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the request's input validation fails
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentRuntimeErrorType: Equatable {
    public static func == (lhs: BedrockAgentRuntimeErrorType, rhs: BedrockAgentRuntimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentRuntimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
