//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS CleanRoomsML service.
///
/// API Reference for Amazon Web Services Clean Rooms ML.
public struct CleanRoomsML: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the CleanRoomsML client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "cleanrooms-ml",
            serviceProtocol: .restjson,
            apiVersion: "2023-09-06",
            endpoint: endpoint,
            errorType: CleanRoomsMLErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Defines the information necessary to create an audience model. An audience model is a machine learning model that Clean Rooms ML trains to measure similarity between users. Clean Rooms ML manages training and storing the audience model. The audience model can be used in multiple calls to the StartAudienceGenerationJob API.
    public func createAudienceModel(_ input: CreateAudienceModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateAudienceModelResponse> {
        return self.client.execute(operation: "CreateAudienceModel", path: "/audience-model", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Defines the information necessary to create a configured audience model.
    public func createConfiguredAudienceModel(_ input: CreateConfiguredAudienceModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConfiguredAudienceModelResponse> {
        return self.client.execute(operation: "CreateConfiguredAudienceModel", path: "/configured-audience-model", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Defines the information necessary to create a training dataset, or seed audience. In Clean Rooms ML, the TrainingDataset is metadata that points to a Glue table, which is read only during AudienceModel creation.
    public func createTrainingDataset(_ input: CreateTrainingDatasetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateTrainingDatasetResponse> {
        return self.client.execute(operation: "CreateTrainingDataset", path: "/training-dataset", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the specified audience generation job, and removes all data associated with the job.
    @discardableResult public func deleteAudienceGenerationJob(_ input: DeleteAudienceGenerationJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteAudienceGenerationJob", path: "/audience-generation-job/{audienceGenerationJobArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Specifies an audience model that you want to delete. You can't delete an audience model if there are any configured audience models that depend on the audience model.
    @discardableResult public func deleteAudienceModel(_ input: DeleteAudienceModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteAudienceModel", path: "/audience-model/{audienceModelArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the specified configured audience model. You can't delete a configured audience model if there are any lookalike models that use the configured audience model. If you delete a configured audience model, it will be removed from any collaborations that it is associated to.
    @discardableResult public func deleteConfiguredAudienceModel(_ input: DeleteConfiguredAudienceModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteConfiguredAudienceModel", path: "/configured-audience-model/{configuredAudienceModelArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the specified configured audience model policy.
    @discardableResult public func deleteConfiguredAudienceModelPolicy(_ input: DeleteConfiguredAudienceModelPolicyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteConfiguredAudienceModelPolicy", path: "/configured-audience-model/{configuredAudienceModelArn}/policy", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Specifies a training dataset that you want to delete. You can't delete a training dataset if there are any audience models that depend on the training dataset. In Clean Rooms ML, the TrainingDataset is metadata that points to a Glue table, which is read only during AudienceModel creation. This action deletes the metadata.
    @discardableResult public func deleteTrainingDataset(_ input: DeleteTrainingDatasetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteTrainingDataset", path: "/training-dataset/{trainingDatasetArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns information about an audience generation job.
    public func getAudienceGenerationJob(_ input: GetAudienceGenerationJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetAudienceGenerationJobResponse> {
        return self.client.execute(operation: "GetAudienceGenerationJob", path: "/audience-generation-job/{audienceGenerationJobArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns information about an audience model
    public func getAudienceModel(_ input: GetAudienceModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetAudienceModelResponse> {
        return self.client.execute(operation: "GetAudienceModel", path: "/audience-model/{audienceModelArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns information about a specified configured audience model.
    public func getConfiguredAudienceModel(_ input: GetConfiguredAudienceModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConfiguredAudienceModelResponse> {
        return self.client.execute(operation: "GetConfiguredAudienceModel", path: "/configured-audience-model/{configuredAudienceModelArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns information about a configured audience model policy.
    public func getConfiguredAudienceModelPolicy(_ input: GetConfiguredAudienceModelPolicyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConfiguredAudienceModelPolicyResponse> {
        return self.client.execute(operation: "GetConfiguredAudienceModelPolicy", path: "/configured-audience-model/{configuredAudienceModelArn}/policy", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns information about a training dataset.
    public func getTrainingDataset(_ input: GetTrainingDatasetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetTrainingDatasetResponse> {
        return self.client.execute(operation: "GetTrainingDataset", path: "/training-dataset/{trainingDatasetArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns a list of the audience export jobs.
    public func listAudienceExportJobs(_ input: ListAudienceExportJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAudienceExportJobsResponse> {
        return self.client.execute(operation: "ListAudienceExportJobs", path: "/audience-export-job", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns a list of audience generation jobs.
    public func listAudienceGenerationJobs(_ input: ListAudienceGenerationJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAudienceGenerationJobsResponse> {
        return self.client.execute(operation: "ListAudienceGenerationJobs", path: "/audience-generation-job", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns a list of audience models.
    public func listAudienceModels(_ input: ListAudienceModelsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAudienceModelsResponse> {
        return self.client.execute(operation: "ListAudienceModels", path: "/audience-model", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns a list of the configured audience models.
    public func listConfiguredAudienceModels(_ input: ListConfiguredAudienceModelsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListConfiguredAudienceModelsResponse> {
        return self.client.execute(operation: "ListConfiguredAudienceModels", path: "/configured-audience-model", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns a list of tags for a provided resource.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceResponse> {
        return self.client.execute(operation: "ListTagsForResource", path: "/tags/{resourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns a list of training datasets.
    public func listTrainingDatasets(_ input: ListTrainingDatasetsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTrainingDatasetsResponse> {
        return self.client.execute(operation: "ListTrainingDatasets", path: "/training-dataset", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Create or update the resource policy for a configured audience model.
    public func putConfiguredAudienceModelPolicy(_ input: PutConfiguredAudienceModelPolicyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutConfiguredAudienceModelPolicyResponse> {
        return self.client.execute(operation: "PutConfiguredAudienceModelPolicy", path: "/configured-audience-model/{configuredAudienceModelArn}/policy", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Export an audience of a specified size after you have generated an audience.
    @discardableResult public func startAudienceExportJob(_ input: StartAudienceExportJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "StartAudienceExportJob", path: "/audience-export-job", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Information necessary to start the audience generation job.
    public func startAudienceGenerationJob(_ input: StartAudienceGenerationJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartAudienceGenerationJobResponse> {
        return self.client.execute(operation: "StartAudienceGenerationJob", path: "/audience-generation-job", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds metadata tags to a specified resource.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceResponse> {
        return self.client.execute(operation: "TagResource", path: "/tags/{resourceArn}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes metadata tags from a specified resource.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceResponse> {
        return self.client.execute(operation: "UntagResource", path: "/tags/{resourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Provides the information necessary to update a configured audience model. Updates that impact audience generation jobs take effect when a new job starts, but do not impact currently running jobs.
    public func updateConfiguredAudienceModel(_ input: UpdateConfiguredAudienceModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConfiguredAudienceModelResponse> {
        return self.client.execute(operation: "UpdateConfiguredAudienceModel", path: "/configured-audience-model/{configuredAudienceModelArn}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension CleanRoomsML {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: CleanRoomsML, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension CleanRoomsML {
    /// Returns a list of the audience export jobs.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAudienceExportJobsPaginator<Result>(
        _ input: ListAudienceExportJobsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAudienceExportJobsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAudienceExportJobs,
            inputKey: \ListAudienceExportJobsRequest.nextToken,
            outputKey: \ListAudienceExportJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAudienceExportJobsPaginator(
        _ input: ListAudienceExportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAudienceExportJobsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAudienceExportJobs,
            inputKey: \ListAudienceExportJobsRequest.nextToken,
            outputKey: \ListAudienceExportJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Returns a list of audience generation jobs.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAudienceGenerationJobsPaginator<Result>(
        _ input: ListAudienceGenerationJobsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAudienceGenerationJobsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAudienceGenerationJobs,
            inputKey: \ListAudienceGenerationJobsRequest.nextToken,
            outputKey: \ListAudienceGenerationJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAudienceGenerationJobsPaginator(
        _ input: ListAudienceGenerationJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAudienceGenerationJobsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAudienceGenerationJobs,
            inputKey: \ListAudienceGenerationJobsRequest.nextToken,
            outputKey: \ListAudienceGenerationJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Returns a list of audience models.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAudienceModelsPaginator<Result>(
        _ input: ListAudienceModelsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAudienceModelsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAudienceModels,
            inputKey: \ListAudienceModelsRequest.nextToken,
            outputKey: \ListAudienceModelsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAudienceModelsPaginator(
        _ input: ListAudienceModelsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAudienceModelsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAudienceModels,
            inputKey: \ListAudienceModelsRequest.nextToken,
            outputKey: \ListAudienceModelsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Returns a list of the configured audience models.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listConfiguredAudienceModelsPaginator<Result>(
        _ input: ListConfiguredAudienceModelsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListConfiguredAudienceModelsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listConfiguredAudienceModels,
            inputKey: \ListConfiguredAudienceModelsRequest.nextToken,
            outputKey: \ListConfiguredAudienceModelsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listConfiguredAudienceModelsPaginator(
        _ input: ListConfiguredAudienceModelsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListConfiguredAudienceModelsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listConfiguredAudienceModels,
            inputKey: \ListConfiguredAudienceModelsRequest.nextToken,
            outputKey: \ListConfiguredAudienceModelsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Returns a list of training datasets.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTrainingDatasetsPaginator<Result>(
        _ input: ListTrainingDatasetsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListTrainingDatasetsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listTrainingDatasets,
            inputKey: \ListTrainingDatasetsRequest.nextToken,
            outputKey: \ListTrainingDatasetsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTrainingDatasetsPaginator(
        _ input: ListTrainingDatasetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListTrainingDatasetsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listTrainingDatasets,
            inputKey: \ListTrainingDatasetsRequest.nextToken,
            outputKey: \ListTrainingDatasetsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension CleanRoomsML.ListAudienceExportJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRoomsML.ListAudienceExportJobsRequest {
        return .init(
            audienceGenerationJobArn: self.audienceGenerationJobArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension CleanRoomsML.ListAudienceGenerationJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRoomsML.ListAudienceGenerationJobsRequest {
        return .init(
            collaborationId: self.collaborationId,
            configuredAudienceModelArn: self.configuredAudienceModelArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension CleanRoomsML.ListAudienceModelsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRoomsML.ListAudienceModelsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension CleanRoomsML.ListConfiguredAudienceModelsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRoomsML.ListConfiguredAudienceModelsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension CleanRoomsML.ListTrainingDatasetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRoomsML.ListTrainingDatasetsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
