//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS QBusiness service.
///
///
public struct QBusiness: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the QBusiness client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "qbusiness",
            serviceProtocol: .restjson,
            apiVersion: "2023-11-27",
            endpoint: endpoint,
            serviceEndpoints: [
                "af-south-1": "qbusiness.af-south-1.api.aws",
                "ap-east-1": "qbusiness.ap-east-1.api.aws",
                "ap-northeast-1": "qbusiness.ap-northeast-1.api.aws",
                "ap-northeast-2": "qbusiness.ap-northeast-2.api.aws",
                "ap-northeast-3": "qbusiness.ap-northeast-3.api.aws",
                "ap-south-1": "qbusiness.ap-south-1.api.aws",
                "ap-south-2": "qbusiness.ap-south-2.api.aws",
                "ap-southeast-1": "qbusiness.ap-southeast-1.api.aws",
                "ap-southeast-2": "qbusiness.ap-southeast-2.api.aws",
                "ap-southeast-3": "qbusiness.ap-southeast-3.api.aws",
                "ap-southeast-4": "qbusiness.ap-southeast-4.api.aws",
                "ca-central-1": "qbusiness.ca-central-1.api.aws",
                "cn-north-1": "qbusiness.cn-north-1.api.amazonwebservices.com.cn",
                "cn-northwest-1": "qbusiness.cn-northwest-1.api.amazonwebservices.com.cn",
                "eu-central-1": "qbusiness.eu-central-1.api.aws",
                "eu-central-2": "qbusiness.eu-central-2.api.aws",
                "eu-north-1": "qbusiness.eu-north-1.api.aws",
                "eu-south-1": "qbusiness.eu-south-1.api.aws",
                "eu-south-2": "qbusiness.eu-south-2.api.aws",
                "eu-west-1": "qbusiness.eu-west-1.api.aws",
                "eu-west-2": "qbusiness.eu-west-2.api.aws",
                "eu-west-3": "qbusiness.eu-west-3.api.aws",
                "il-central-1": "qbusiness.il-central-1.api.aws",
                "me-central-1": "qbusiness.me-central-1.api.aws",
                "me-south-1": "qbusiness.me-south-1.api.aws",
                "sa-east-1": "qbusiness.sa-east-1.api.aws",
                "us-east-1": "qbusiness.us-east-1.api.aws",
                "us-east-2": "qbusiness.us-east-2.api.aws",
                "us-gov-east-1": "qbusiness.us-gov-east-1.api.aws",
                "us-gov-west-1": "qbusiness.us-gov-west-1.api.aws",
                "us-west-1": "qbusiness.us-west-1.api.aws",
                "us-west-2": "qbusiness.us-west-2.api.aws"
            ],
            variantEndpoints: [
                [.fips]: .init(endpoints: [
                    "af-south-1": "qbusiness-fips.af-south-1.api.aws",
                    "ap-east-1": "qbusiness-fips.ap-east-1.api.aws",
                    "ap-northeast-1": "qbusiness-fips.ap-northeast-1.api.aws",
                    "ap-northeast-2": "qbusiness-fips.ap-northeast-2.api.aws",
                    "ap-northeast-3": "qbusiness-fips.ap-northeast-3.api.aws",
                    "ap-south-1": "qbusiness-fips.ap-south-1.api.aws",
                    "ap-south-2": "qbusiness-fips.ap-south-2.api.aws",
                    "ap-southeast-1": "qbusiness-fips.ap-southeast-1.api.aws",
                    "ap-southeast-2": "qbusiness-fips.ap-southeast-2.api.aws",
                    "ap-southeast-3": "qbusiness-fips.ap-southeast-3.api.aws",
                    "ap-southeast-4": "qbusiness-fips.ap-southeast-4.api.aws",
                    "ca-central-1": "qbusiness-fips.ca-central-1.api.aws",
                    "cn-north-1": "qbusiness-fips.cn-north-1.api.amazonwebservices.com.cn",
                    "cn-northwest-1": "qbusiness-fips.cn-northwest-1.api.amazonwebservices.com.cn",
                    "eu-central-1": "qbusiness-fips.eu-central-1.api.aws",
                    "eu-central-2": "qbusiness-fips.eu-central-2.api.aws",
                    "eu-north-1": "qbusiness-fips.eu-north-1.api.aws",
                    "eu-south-1": "qbusiness-fips.eu-south-1.api.aws",
                    "eu-south-2": "qbusiness-fips.eu-south-2.api.aws",
                    "eu-west-1": "qbusiness-fips.eu-west-1.api.aws",
                    "eu-west-2": "qbusiness-fips.eu-west-2.api.aws",
                    "eu-west-3": "qbusiness-fips.eu-west-3.api.aws",
                    "il-central-1": "qbusiness-fips.il-central-1.api.aws",
                    "me-central-1": "qbusiness-fips.me-central-1.api.aws",
                    "me-south-1": "qbusiness-fips.me-south-1.api.aws",
                    "sa-east-1": "qbusiness-fips.sa-east-1.api.aws",
                    "us-east-1": "qbusiness-fips.us-east-1.api.aws",
                    "us-east-2": "qbusiness-fips.us-east-2.api.aws",
                    "us-gov-east-1": "qbusiness-fips.us-gov-east-1.api.aws",
                    "us-gov-west-1": "qbusiness-fips.us-gov-west-1.api.aws",
                    "us-west-1": "qbusiness-fips.us-west-1.api.aws",
                    "us-west-2": "qbusiness-fips.us-west-2.api.aws"
                ])
            ],
            errorType: QBusinessErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Asynchronously deletes one or more documents added using the BatchPutDocument API from an Amazon Q index. You can see the progress of the deletion, and any error messages related to the process, by using CloudWatch.
    public func batchDeleteDocument(_ input: BatchDeleteDocumentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BatchDeleteDocumentResponse> {
        return self.client.execute(operation: "BatchDeleteDocument", path: "/applications/{applicationId}/indices/{indexId}/documents/delete", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds one or more documents to an Amazon Q index. You use this API to:   ingest your structured and unstructured documents and documents stored in an Amazon S3 bucket into an Amazon Q index.   add custom attributes to documents in an Amazon Q index.   attach an access control list to the documents added to an Amazon Q index.   You can see the progress of the deletion, and any error messages related to the process, by using CloudWatch.
    public func batchPutDocument(_ input: BatchPutDocumentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BatchPutDocumentResponse> {
        return self.client.execute(operation: "BatchPutDocument", path: "/applications/{applicationId}/indices/{indexId}/documents", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Starts or continues a non-streaming Amazon Q conversation.
    public func chatSync(_ input: ChatSyncInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ChatSyncOutput> {
        return self.client.execute(operation: "ChatSync", path: "/applications/{applicationId}/conversations?sync", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an Amazon Q application.
    public func createApplication(_ input: CreateApplicationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateApplicationResponse> {
        return self.client.execute(operation: "CreateApplication", path: "/applications", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a data source connector for an Amazon Q application.  CreateDataSource is a synchronous operation. The operation returns 200 if the data source was successfully created. Otherwise, an exception is raised.
    public func createDataSource(_ input: CreateDataSourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDataSourceResponse> {
        return self.client.execute(operation: "CreateDataSource", path: "/applications/{applicationId}/indices/{indexId}/datasources", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an Amazon Q index. To determine if index creation has completed, check the Status field returned from a call to DescribeIndex. The Status field is set to ACTIVE when the index is ready to use. Once the index is active, you can index your documents using the  BatchPutDocument API or the  CreateDataSource API.
    public func createIndex(_ input: CreateIndexRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateIndexResponse> {
        return self.client.execute(operation: "CreateIndex", path: "/applications/{applicationId}/indices", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an Amazon Q plugin.
    public func createPlugin(_ input: CreatePluginRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreatePluginResponse> {
        return self.client.execute(operation: "CreatePlugin", path: "/applications/{applicationId}/plugins", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a retriever to your Amazon Q application.
    public func createRetriever(_ input: CreateRetrieverRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateRetrieverResponse> {
        return self.client.execute(operation: "CreateRetriever", path: "/applications/{applicationId}/retrievers", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a universally unique identifier (UUID) mapped to a list of local user ids within an application.
    public func createUser(_ input: CreateUserRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateUserResponse> {
        return self.client.execute(operation: "CreateUser", path: "/applications/{applicationId}/users", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an Amazon Q web experience.
    public func createWebExperience(_ input: CreateWebExperienceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateWebExperienceResponse> {
        return self.client.execute(operation: "CreateWebExperience", path: "/applications/{applicationId}/experiences", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an Amazon Q application.
    public func deleteApplication(_ input: DeleteApplicationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteApplicationResponse> {
        return self.client.execute(operation: "DeleteApplication", path: "/applications/{applicationId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes chat controls configured for an existing Amazon Q application.
    public func deleteChatControlsConfiguration(_ input: DeleteChatControlsConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteChatControlsConfigurationResponse> {
        return self.client.execute(operation: "DeleteChatControlsConfiguration", path: "/applications/{applicationId}/chatcontrols", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an Amazon Q web experience conversation.
    public func deleteConversation(_ input: DeleteConversationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteConversationResponse> {
        return self.client.execute(operation: "DeleteConversation", path: "/applications/{applicationId}/conversations/{conversationId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an Amazon Q data source connector. While the data source is being deleted, the Status field returned by a call to the DescribeDataSource API is set to DELETING.
    public func deleteDataSource(_ input: DeleteDataSourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteDataSourceResponse> {
        return self.client.execute(operation: "DeleteDataSource", path: "/applications/{applicationId}/indices/{indexId}/datasources/{dataSourceId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a group so that all users and sub groups that belong to the group can no longer access documents only available to that group. For example, after deleting the group "Summer Interns", all interns who belonged to that group no longer see intern-only documents in their chat results.  If you want to delete, update, or replace users or sub groups of a group, you need to use the PutGroup operation. For example, if a user in the group "Engineering" leaves the engineering team and another user takes their place, you provide an updated list of users or sub groups that belong to the "Engineering" group when calling PutGroup.
    public func deleteGroup(_ input: DeleteGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteGroupResponse> {
        return self.client.execute(operation: "DeleteGroup", path: "/applications/{applicationId}/indices/{indexId}/groups/{groupName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an Amazon Q index.
    public func deleteIndex(_ input: DeleteIndexRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteIndexResponse> {
        return self.client.execute(operation: "DeleteIndex", path: "/applications/{applicationId}/indices/{indexId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an Amazon Q plugin.
    public func deletePlugin(_ input: DeletePluginRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeletePluginResponse> {
        return self.client.execute(operation: "DeletePlugin", path: "/applications/{applicationId}/plugins/{pluginId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the retriever used by an Amazon Q application.
    public func deleteRetriever(_ input: DeleteRetrieverRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteRetrieverResponse> {
        return self.client.execute(operation: "DeleteRetriever", path: "/applications/{applicationId}/retrievers/{retrieverId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a user by email id.
    public func deleteUser(_ input: DeleteUserRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteUserResponse> {
        return self.client.execute(operation: "DeleteUser", path: "/applications/{applicationId}/users/{userId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an Amazon Q web experience.
    public func deleteWebExperience(_ input: DeleteWebExperienceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteWebExperienceResponse> {
        return self.client.execute(operation: "DeleteWebExperience", path: "/applications/{applicationId}/experiences/{webExperienceId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about an existing Amazon Q application.
    public func getApplication(_ input: GetApplicationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetApplicationResponse> {
        return self.client.execute(operation: "GetApplication", path: "/applications/{applicationId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about an chat controls configured for an existing Amazon Q application.
    public func getChatControlsConfiguration(_ input: GetChatControlsConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetChatControlsConfigurationResponse> {
        return self.client.execute(operation: "GetChatControlsConfiguration", path: "/applications/{applicationId}/chatcontrols", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about an existing Amazon Q data source connector.
    public func getDataSource(_ input: GetDataSourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDataSourceResponse> {
        return self.client.execute(operation: "GetDataSource", path: "/applications/{applicationId}/indices/{indexId}/datasources/{dataSourceId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes a group by group name.
    public func getGroup(_ input: GetGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGroupResponse> {
        return self.client.execute(operation: "GetGroup", path: "/applications/{applicationId}/indices/{indexId}/groups/{groupName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about an existing Amazon Q index.
    public func getIndex(_ input: GetIndexRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetIndexResponse> {
        return self.client.execute(operation: "GetIndex", path: "/applications/{applicationId}/indices/{indexId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about an existing Amazon Q plugin.
    public func getPlugin(_ input: GetPluginRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPluginResponse> {
        return self.client.execute(operation: "GetPlugin", path: "/applications/{applicationId}/plugins/{pluginId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about an existing retriever used by an Amazon Q application.
    public func getRetriever(_ input: GetRetrieverRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetRetrieverResponse> {
        return self.client.execute(operation: "GetRetriever", path: "/applications/{applicationId}/retrievers/{retrieverId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes the universally unique identifier (UUID) associated with a local user in a data source.
    public func getUser(_ input: GetUserRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetUserResponse> {
        return self.client.execute(operation: "GetUser", path: "/applications/{applicationId}/users/{userId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about an existing Amazon Q web experience.
    public func getWebExperience(_ input: GetWebExperienceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetWebExperienceResponse> {
        return self.client.execute(operation: "GetWebExperience", path: "/applications/{applicationId}/experiences/{webExperienceId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists Amazon Q applications.
    public func listApplications(_ input: ListApplicationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListApplicationsResponse> {
        return self.client.execute(operation: "ListApplications", path: "/applications", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists one or more Amazon Q conversations.
    public func listConversations(_ input: ListConversationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListConversationsResponse> {
        return self.client.execute(operation: "ListConversations", path: "/applications/{applicationId}/conversations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get information about an Amazon Q data source connector synchronization.
    public func listDataSourceSyncJobs(_ input: ListDataSourceSyncJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDataSourceSyncJobsResponse> {
        return self.client.execute(operation: "ListDataSourceSyncJobs", path: "/applications/{applicationId}/indices/{indexId}/datasources/{dataSourceId}/syncjobs", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the Amazon Q data source connectors that you have created.
    public func listDataSources(_ input: ListDataSourcesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDataSourcesResponse> {
        return self.client.execute(operation: "ListDataSources", path: "/applications/{applicationId}/indices/{indexId}/datasources", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// A list of documents attached to an index.
    public func listDocuments(_ input: ListDocumentsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDocumentsResponse> {
        return self.client.execute(operation: "ListDocuments", path: "/applications/{applicationId}/index/{indexId}/documents", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Provides a list of groups that are mapped to users.
    public func listGroups(_ input: ListGroupsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListGroupsResponse> {
        return self.client.execute(operation: "ListGroups", path: "/applications/{applicationId}/indices/{indexId}/groups", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the Amazon Q indices you have created.
    public func listIndices(_ input: ListIndicesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListIndicesResponse> {
        return self.client.execute(operation: "ListIndices", path: "/applications/{applicationId}/indices", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a list of messages associated with an Amazon Q web experience.
    public func listMessages(_ input: ListMessagesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListMessagesResponse> {
        return self.client.execute(operation: "ListMessages", path: "/applications/{applicationId}/conversations/{conversationId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists configured Amazon Q plugins.
    public func listPlugins(_ input: ListPluginsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListPluginsResponse> {
        return self.client.execute(operation: "ListPlugins", path: "/applications/{applicationId}/plugins", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the retriever used by an Amazon Q application.
    public func listRetrievers(_ input: ListRetrieversRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListRetrieversResponse> {
        return self.client.execute(operation: "ListRetrievers", path: "/applications/{applicationId}/retrievers", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a list of tags associated with a specified resource. Amazon Q applications and data sources can have tags associated with them.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceResponse> {
        return self.client.execute(operation: "ListTagsForResource", path: "/v1/tags/{resourceARN}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists one or more Amazon Q Web Experiences.
    public func listWebExperiences(_ input: ListWebExperiencesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListWebExperiencesResponse> {
        return self.client.execute(operation: "ListWebExperiences", path: "/applications/{applicationId}/experiences", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Enables your end user to to provide feedback on their Amazon Q generated chat responses.
    @discardableResult public func putFeedback(_ input: PutFeedbackRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "PutFeedback", path: "/applications/{applicationId}/conversations/{conversationId}/messages/{messageId}/feedback", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Create, or updates, a mapping of users—who have access to a document—to groups. You can also map sub groups to groups. For example, the group "Company Intellectual Property Teams" includes sub groups "Research" and "Engineering". These sub groups include their own list of users or people who work in these teams. Only users who work in research and engineering, and therefore belong in the intellectual property group, can see top-secret company documents in their Amazon Q chat results.
    public func putGroup(_ input: PutGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutGroupResponse> {
        return self.client.execute(operation: "PutGroup", path: "/applications/{applicationId}/indices/{indexId}/groups", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Starts a data source connector synchronization job. If a synchronization job is already in progress, Amazon Q returns a ConflictException.
    public func startDataSourceSyncJob(_ input: StartDataSourceSyncJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartDataSourceSyncJobResponse> {
        return self.client.execute(operation: "StartDataSourceSyncJob", path: "/applications/{applicationId}/indices/{indexId}/datasources/{dataSourceId}/startsync", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Stops an Amazon Q data source connector synchronization job already in progress.
    public func stopDataSourceSyncJob(_ input: StopDataSourceSyncJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StopDataSourceSyncJobResponse> {
        return self.client.execute(operation: "StopDataSourceSyncJob", path: "/applications/{applicationId}/indices/{indexId}/datasources/{dataSourceId}/stopsync", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds the specified tag to the specified Amazon Q application or data source resource. If the tag already exists, the existing value is replaced with the new value.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceResponse> {
        return self.client.execute(operation: "TagResource", path: "/v1/tags/{resourceARN}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes a tag from an Amazon Q application or a data source.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceResponse> {
        return self.client.execute(operation: "UntagResource", path: "/v1/tags/{resourceARN}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing Amazon Q application.
    public func updateApplication(_ input: UpdateApplicationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateApplicationResponse> {
        return self.client.execute(operation: "UpdateApplication", path: "/applications/{applicationId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an set of chat controls configured for an existing Amazon Q application.
    public func updateChatControlsConfiguration(_ input: UpdateChatControlsConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateChatControlsConfigurationResponse> {
        return self.client.execute(operation: "UpdateChatControlsConfiguration", path: "/applications/{applicationId}/chatcontrols", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing Amazon Q data source connector.
    public func updateDataSource(_ input: UpdateDataSourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateDataSourceResponse> {
        return self.client.execute(operation: "UpdateDataSource", path: "/applications/{applicationId}/indices/{indexId}/datasources/{dataSourceId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an Amazon Q index.
    public func updateIndex(_ input: UpdateIndexRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateIndexResponse> {
        return self.client.execute(operation: "UpdateIndex", path: "/applications/{applicationId}/indices/{indexId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an Amazon Q plugin.
    public func updatePlugin(_ input: UpdatePluginRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdatePluginResponse> {
        return self.client.execute(operation: "UpdatePlugin", path: "/applications/{applicationId}/plugins/{pluginId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the retriever used for your Amazon Q application.
    public func updateRetriever(_ input: UpdateRetrieverRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateRetrieverResponse> {
        return self.client.execute(operation: "UpdateRetriever", path: "/applications/{applicationId}/retrievers/{retrieverId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a information associated with a user id.
    public func updateUser(_ input: UpdateUserRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateUserResponse> {
        return self.client.execute(operation: "UpdateUser", path: "/applications/{applicationId}/users/{userId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an Amazon Q web experience.
    public func updateWebExperience(_ input: UpdateWebExperienceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateWebExperienceResponse> {
        return self.client.execute(operation: "UpdateWebExperience", path: "/applications/{applicationId}/experiences/{webExperienceId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension QBusiness {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: QBusiness, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension QBusiness {
    /// Gets information about an chat controls configured for an existing Amazon Q application.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getChatControlsConfigurationPaginator<Result>(
        _ input: GetChatControlsConfigurationRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetChatControlsConfigurationResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getChatControlsConfiguration,
            inputKey: \GetChatControlsConfigurationRequest.nextToken,
            outputKey: \GetChatControlsConfigurationResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getChatControlsConfigurationPaginator(
        _ input: GetChatControlsConfigurationRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetChatControlsConfigurationResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getChatControlsConfiguration,
            inputKey: \GetChatControlsConfigurationRequest.nextToken,
            outputKey: \GetChatControlsConfigurationResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists Amazon Q applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listApplicationsPaginator<Result>(
        _ input: ListApplicationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListApplicationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listApplications,
            inputKey: \ListApplicationsRequest.nextToken,
            outputKey: \ListApplicationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listApplicationsPaginator(
        _ input: ListApplicationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListApplicationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listApplications,
            inputKey: \ListApplicationsRequest.nextToken,
            outputKey: \ListApplicationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists one or more Amazon Q conversations.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listConversationsPaginator<Result>(
        _ input: ListConversationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListConversationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listConversations,
            inputKey: \ListConversationsRequest.nextToken,
            outputKey: \ListConversationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listConversationsPaginator(
        _ input: ListConversationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListConversationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listConversations,
            inputKey: \ListConversationsRequest.nextToken,
            outputKey: \ListConversationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Get information about an Amazon Q data source connector synchronization.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDataSourceSyncJobsPaginator<Result>(
        _ input: ListDataSourceSyncJobsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDataSourceSyncJobsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDataSourceSyncJobs,
            inputKey: \ListDataSourceSyncJobsRequest.nextToken,
            outputKey: \ListDataSourceSyncJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDataSourceSyncJobsPaginator(
        _ input: ListDataSourceSyncJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDataSourceSyncJobsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDataSourceSyncJobs,
            inputKey: \ListDataSourceSyncJobsRequest.nextToken,
            outputKey: \ListDataSourceSyncJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists the Amazon Q data source connectors that you have created.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDataSourcesPaginator<Result>(
        _ input: ListDataSourcesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDataSourcesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDataSources,
            inputKey: \ListDataSourcesRequest.nextToken,
            outputKey: \ListDataSourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDataSourcesPaginator(
        _ input: ListDataSourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDataSourcesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDataSources,
            inputKey: \ListDataSourcesRequest.nextToken,
            outputKey: \ListDataSourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// A list of documents attached to an index.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDocumentsPaginator<Result>(
        _ input: ListDocumentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDocumentsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDocuments,
            inputKey: \ListDocumentsRequest.nextToken,
            outputKey: \ListDocumentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDocumentsPaginator(
        _ input: ListDocumentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDocumentsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDocuments,
            inputKey: \ListDocumentsRequest.nextToken,
            outputKey: \ListDocumentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provides a list of groups that are mapped to users.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listGroupsPaginator<Result>(
        _ input: ListGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListGroupsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listGroups,
            inputKey: \ListGroupsRequest.nextToken,
            outputKey: \ListGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listGroupsPaginator(
        _ input: ListGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListGroupsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listGroups,
            inputKey: \ListGroupsRequest.nextToken,
            outputKey: \ListGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists the Amazon Q indices you have created.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listIndicesPaginator<Result>(
        _ input: ListIndicesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListIndicesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listIndices,
            inputKey: \ListIndicesRequest.nextToken,
            outputKey: \ListIndicesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listIndicesPaginator(
        _ input: ListIndicesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListIndicesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listIndices,
            inputKey: \ListIndicesRequest.nextToken,
            outputKey: \ListIndicesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Gets a list of messages associated with an Amazon Q web experience.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listMessagesPaginator<Result>(
        _ input: ListMessagesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListMessagesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listMessages,
            inputKey: \ListMessagesRequest.nextToken,
            outputKey: \ListMessagesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listMessagesPaginator(
        _ input: ListMessagesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListMessagesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listMessages,
            inputKey: \ListMessagesRequest.nextToken,
            outputKey: \ListMessagesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists configured Amazon Q plugins.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPluginsPaginator<Result>(
        _ input: ListPluginsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPluginsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listPlugins,
            inputKey: \ListPluginsRequest.nextToken,
            outputKey: \ListPluginsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPluginsPaginator(
        _ input: ListPluginsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPluginsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listPlugins,
            inputKey: \ListPluginsRequest.nextToken,
            outputKey: \ListPluginsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists the retriever used by an Amazon Q application.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listRetrieversPaginator<Result>(
        _ input: ListRetrieversRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListRetrieversResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listRetrievers,
            inputKey: \ListRetrieversRequest.nextToken,
            outputKey: \ListRetrieversResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listRetrieversPaginator(
        _ input: ListRetrieversRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListRetrieversResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listRetrievers,
            inputKey: \ListRetrieversRequest.nextToken,
            outputKey: \ListRetrieversResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists one or more Amazon Q Web Experiences.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listWebExperiencesPaginator<Result>(
        _ input: ListWebExperiencesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListWebExperiencesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listWebExperiences,
            inputKey: \ListWebExperiencesRequest.nextToken,
            outputKey: \ListWebExperiencesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listWebExperiencesPaginator(
        _ input: ListWebExperiencesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListWebExperiencesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listWebExperiences,
            inputKey: \ListWebExperiencesRequest.nextToken,
            outputKey: \ListWebExperiencesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension QBusiness.GetChatControlsConfigurationRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.GetChatControlsConfigurationRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension QBusiness.ListApplicationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListApplicationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension QBusiness.ListConversationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListConversationsRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token,
            userId: self.userId
        )
    }
}

extension QBusiness.ListDataSourceSyncJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListDataSourceSyncJobsRequest {
        return .init(
            applicationId: self.applicationId,
            dataSourceId: self.dataSourceId,
            endTime: self.endTime,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            statusFilter: self.statusFilter
        )
    }
}

extension QBusiness.ListDataSourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListDataSourcesRequest {
        return .init(
            applicationId: self.applicationId,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension QBusiness.ListDocumentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListDocumentsRequest {
        return .init(
            applicationId: self.applicationId,
            dataSourceIds: self.dataSourceIds,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension QBusiness.ListGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListGroupsRequest {
        return .init(
            applicationId: self.applicationId,
            dataSourceId: self.dataSourceId,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token,
            updatedEarlierThan: self.updatedEarlierThan
        )
    }
}

extension QBusiness.ListIndicesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListIndicesRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension QBusiness.ListMessagesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListMessagesRequest {
        return .init(
            applicationId: self.applicationId,
            conversationId: self.conversationId,
            maxResults: self.maxResults,
            nextToken: token,
            userId: self.userId
        )
    }
}

extension QBusiness.ListPluginsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListPluginsRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension QBusiness.ListRetrieversRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListRetrieversRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension QBusiness.ListWebExperiencesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> QBusiness.ListWebExperiencesRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
