//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS TrustedAdvisor service.
///
/// TrustedAdvisor Public API
public struct TrustedAdvisor: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the TrustedAdvisor client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "trustedadvisor",
            serviceProtocol: .restjson,
            apiVersion: "2022-09-15",
            endpoint: endpoint,
            errorType: TrustedAdvisorErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Get a specific recommendation within an AWS Organizations organization. This API supports only prioritized recommendations.
    public func getOrganizationRecommendation(_ input: GetOrganizationRecommendationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetOrganizationRecommendationResponse> {
        return self.client.execute(operation: "GetOrganizationRecommendation", path: "/v1/organization-recommendations/{organizationRecommendationIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get a specific Recommendation
    public func getRecommendation(_ input: GetRecommendationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetRecommendationResponse> {
        return self.client.execute(operation: "GetRecommendation", path: "/v1/recommendations/{recommendationIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List a filterable set of Checks
    public func listChecks(_ input: ListChecksRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListChecksResponse> {
        return self.client.execute(operation: "ListChecks", path: "/v1/checks", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the accounts that own the resources for an organization aggregate recommendation. This API only supports prioritized recommendations.
    public func listOrganizationRecommendationAccounts(_ input: ListOrganizationRecommendationAccountsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListOrganizationRecommendationAccountsResponse> {
        return self.client.execute(operation: "ListOrganizationRecommendationAccounts", path: "/v1/organization-recommendations/{organizationRecommendationIdentifier}/accounts", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List Resources of a Recommendation within an Organization. This API only supports prioritized recommendations.
    public func listOrganizationRecommendationResources(_ input: ListOrganizationRecommendationResourcesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListOrganizationRecommendationResourcesResponse> {
        return self.client.execute(operation: "ListOrganizationRecommendationResources", path: "/v1/organization-recommendations/{organizationRecommendationIdentifier}/resources", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List a filterable set of Recommendations within an Organization. This API only supports prioritized recommendations.
    public func listOrganizationRecommendations(_ input: ListOrganizationRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListOrganizationRecommendationsResponse> {
        return self.client.execute(operation: "ListOrganizationRecommendations", path: "/v1/organization-recommendations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List Resources of a Recommendation
    public func listRecommendationResources(_ input: ListRecommendationResourcesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListRecommendationResourcesResponse> {
        return self.client.execute(operation: "ListRecommendationResources", path: "/v1/recommendations/{recommendationIdentifier}/resources", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List a filterable set of Recommendations
    public func listRecommendations(_ input: ListRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListRecommendationsResponse> {
        return self.client.execute(operation: "ListRecommendations", path: "/v1/recommendations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update the lifecyle of a Recommendation within an Organization. This API only supports prioritized recommendations.
    @discardableResult public func updateOrganizationRecommendationLifecycle(_ input: UpdateOrganizationRecommendationLifecycleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "UpdateOrganizationRecommendationLifecycle", path: "/v1/organization-recommendations/{organizationRecommendationIdentifier}/lifecycle", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update the lifecyle of a Recommendation. This API only supports prioritized recommendations.
    @discardableResult public func updateRecommendationLifecycle(_ input: UpdateRecommendationLifecycleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "UpdateRecommendationLifecycle", path: "/v1/recommendations/{recommendationIdentifier}/lifecycle", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension TrustedAdvisor {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: TrustedAdvisor, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension TrustedAdvisor {
    /// List a filterable set of Checks
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listChecksPaginator<Result>(
        _ input: ListChecksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListChecksResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listChecks,
            inputKey: \ListChecksRequest.nextToken,
            outputKey: \ListChecksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listChecksPaginator(
        _ input: ListChecksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListChecksResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listChecks,
            inputKey: \ListChecksRequest.nextToken,
            outputKey: \ListChecksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists the accounts that own the resources for an organization aggregate recommendation. This API only supports prioritized recommendations.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOrganizationRecommendationAccountsPaginator<Result>(
        _ input: ListOrganizationRecommendationAccountsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListOrganizationRecommendationAccountsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listOrganizationRecommendationAccounts,
            inputKey: \ListOrganizationRecommendationAccountsRequest.nextToken,
            outputKey: \ListOrganizationRecommendationAccountsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOrganizationRecommendationAccountsPaginator(
        _ input: ListOrganizationRecommendationAccountsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListOrganizationRecommendationAccountsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listOrganizationRecommendationAccounts,
            inputKey: \ListOrganizationRecommendationAccountsRequest.nextToken,
            outputKey: \ListOrganizationRecommendationAccountsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// List Resources of a Recommendation within an Organization. This API only supports prioritized recommendations.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOrganizationRecommendationResourcesPaginator<Result>(
        _ input: ListOrganizationRecommendationResourcesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListOrganizationRecommendationResourcesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listOrganizationRecommendationResources,
            inputKey: \ListOrganizationRecommendationResourcesRequest.nextToken,
            outputKey: \ListOrganizationRecommendationResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOrganizationRecommendationResourcesPaginator(
        _ input: ListOrganizationRecommendationResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListOrganizationRecommendationResourcesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listOrganizationRecommendationResources,
            inputKey: \ListOrganizationRecommendationResourcesRequest.nextToken,
            outputKey: \ListOrganizationRecommendationResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// List a filterable set of Recommendations within an Organization. This API only supports prioritized recommendations.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOrganizationRecommendationsPaginator<Result>(
        _ input: ListOrganizationRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListOrganizationRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listOrganizationRecommendations,
            inputKey: \ListOrganizationRecommendationsRequest.nextToken,
            outputKey: \ListOrganizationRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOrganizationRecommendationsPaginator(
        _ input: ListOrganizationRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListOrganizationRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listOrganizationRecommendations,
            inputKey: \ListOrganizationRecommendationsRequest.nextToken,
            outputKey: \ListOrganizationRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// List Resources of a Recommendation
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listRecommendationResourcesPaginator<Result>(
        _ input: ListRecommendationResourcesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListRecommendationResourcesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listRecommendationResources,
            inputKey: \ListRecommendationResourcesRequest.nextToken,
            outputKey: \ListRecommendationResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listRecommendationResourcesPaginator(
        _ input: ListRecommendationResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListRecommendationResourcesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listRecommendationResources,
            inputKey: \ListRecommendationResourcesRequest.nextToken,
            outputKey: \ListRecommendationResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// List a filterable set of Recommendations
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listRecommendationsPaginator<Result>(
        _ input: ListRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listRecommendations,
            inputKey: \ListRecommendationsRequest.nextToken,
            outputKey: \ListRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listRecommendationsPaginator(
        _ input: ListRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listRecommendations,
            inputKey: \ListRecommendationsRequest.nextToken,
            outputKey: \ListRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension TrustedAdvisor.ListChecksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> TrustedAdvisor.ListChecksRequest {
        return .init(
            awsService: self.awsService,
            language: self.language,
            maxResults: self.maxResults,
            nextToken: token,
            pillar: self.pillar,
            source: self.source
        )
    }
}

extension TrustedAdvisor.ListOrganizationRecommendationAccountsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> TrustedAdvisor.ListOrganizationRecommendationAccountsRequest {
        return .init(
            affectedAccountId: self.affectedAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            organizationRecommendationIdentifier: self.organizationRecommendationIdentifier
        )
    }
}

extension TrustedAdvisor.ListOrganizationRecommendationResourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> TrustedAdvisor.ListOrganizationRecommendationResourcesRequest {
        return .init(
            affectedAccountId: self.affectedAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            organizationRecommendationIdentifier: self.organizationRecommendationIdentifier,
            regionCode: self.regionCode,
            status: self.status
        )
    }
}

extension TrustedAdvisor.ListOrganizationRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> TrustedAdvisor.ListOrganizationRecommendationsRequest {
        return .init(
            afterLastUpdatedAt: self.afterLastUpdatedAt,
            awsService: self.awsService,
            beforeLastUpdatedAt: self.beforeLastUpdatedAt,
            checkIdentifier: self.checkIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            pillar: self.pillar,
            source: self.source,
            status: self.status,
            type: self.type
        )
    }
}

extension TrustedAdvisor.ListRecommendationResourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> TrustedAdvisor.ListRecommendationResourcesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            recommendationIdentifier: self.recommendationIdentifier,
            regionCode: self.regionCode,
            status: self.status
        )
    }
}

extension TrustedAdvisor.ListRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> TrustedAdvisor.ListRecommendationsRequest {
        return .init(
            afterLastUpdatedAt: self.afterLastUpdatedAt,
            awsService: self.awsService,
            beforeLastUpdatedAt: self.beforeLastUpdatedAt,
            checkIdentifier: self.checkIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            pillar: self.pillar,
            source: self.source,
            status: self.status,
            type: self.type
        )
    }
}
